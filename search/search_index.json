{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mergerfs - a featureful union filesystem","text":"<p>mergerfs is a FUSE based union filesystem geared towards simplifying storage and management of files across numerous commodity storage devices. It is similar to mhddfs, unionfs, and aufs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Logically combine numerous filesystems/paths into a single   mount point</li> <li>Combine paths of the same or different filesystems</li> <li>Ability to add or remove filesystems/paths without impacting the   rest of the data</li> <li>Unaffected by individual filesystem failure</li> <li>Configurable file selection and creation placement</li> <li>Works with filesystems of any size</li> <li>Works with filesystems of almost any type</li> <li>Ignore read-only filesystems when creating files</li> <li>Hard link copy-on-write / CoW</li> <li>Runtime configurable</li> <li>Support for extended attributes (xattrs)</li> <li>Support for file attributes (chattr)</li> <li>Support for POSIX ACLs</li> </ul>"},{"location":"#non-features","title":"Non-features","text":"<ul> <li>Read/write overlay on top of read-only filesystem like OverlayFS</li> <li>File whiteout</li> <li>RAID like parity calculation</li> <li>Redundancy</li> <li>Splitting of files across branches</li> </ul>"},{"location":"#how-it-works","title":"How it works","text":"<p>mergerfs logically merges multiple filesystem paths together. Not block devices, not filesystem mounts, just paths. It acts as a proxy to the underlying filesystem paths. Combining the behaviors of some functions and being a selector for others.</p> <p>When the contents of a directory are requested mergerfs combines the list of files from each directory, deduplicating entries, and returns that list.</p> <p>When a file or directory is created a policy is first run to determine which branch will be selected for the creation.</p> <p>For functions which change attributes or remove the file the behavior may be applied to all instances found.</p> <p>Read more about policies here.</p>"},{"location":"#visualization","title":"Visualization","text":"<pre><code>A         +      B        =       C\n/disk1           /disk2           /merged\n|                |                |\n+-- /dir1        +-- /dir1        +-- /dir1\n|   |            |   |            |   |\n|   +-- file1    |   +-- file2    |   +-- file1\n|                |   +-- file3    |   +-- file2\n+-- /dir2        |                |   +-- file3\n|   |            +-- /dir3        |\n|   +-- file4        |            +-- /dir2\n|                     +-- file5   |   |\n+-- file6                         |   +-- file4\n                                  |\n                                  +-- /dir3\n                                  |   |\n                                  |   +-- file5\n                                  |\n                                  +-- file6\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Head to the quick start guide.</p>"},{"location":"benchmarking/","title":"Benchmarking","text":"<p>Filesystems are complicated. They do many things and many of those are interconnected. Additionally, the OS, drivers, hardware, etc. can all impact performance. Therefore, when benchmarking, it is necessary that the test focuses as narrowly as possible.</p> <p>For most throughput is the key benchmark. To test throughput <code>dd</code> is useful but must be used with the correct settings in order to ensure the filesystem or device is actually being tested. The OS can and will cache data. Without forcing synchronous reads and writes and/or disabling caching the values returned will not be representative of the device's true performance.</p> <p>When benchmarking through mergerfs ensure you only use 1 branch to remove any possibility of the policies complicating the situation. Benchmark the underlying filesystem first and then mount mergerfs over it and test again. If you're experiencing speeds below your expectation you will need to narrow down precisely which component is leading to the slowdown. Preferably test the following in the order listed (but not combined).</p> <ol> <li>Enable <code>nullrw</code> mode with <code>nullrw=true</code>. This will effectively make    reads and writes no-ops. Removing the underlying device /    filesystem from the equation. This will give us the top theoretical    speeds.</li> <li>Mount mergerfs over <code>tmpfs</code>. <code>tmpfs</code> is a RAM disk. Extremely high    speed and very low latency. This is a more realistic best case    scenario. Example: <code>mount -t tmpfs -o size=2G tmpfs /tmp/tmpfs</code></li> <li>Mount mergerfs over a local device. NVMe, SSD, HDD, etc. If you    have more than one I'd suggest testing each of them as drives    and/or controllers (their drivers) could impact performance.</li> <li>Finally, if you intend to use mergerfs with a network filesystem,    either as the source of data or to combine with another through    mergerfs, test each of those alone as above.</li> </ol> <p>Once you find the component which has the performance issue you can do further testing with different options to see if they impact performance. For reads and writes the most relevant would be: <code>cache.files</code>, <code>async_read</code>. Less likely but relevant when using NFS or with certain filesystems would be <code>security_capability</code>, <code>xattr</code>, and <code>posix_acl</code>. If you find a specific system, device, filesystem, controller, etc. that performs poorly contact trapexit so he may investigate further.</p> <p>Sometimes the problem is really the application accessing or writing data through mergerfs. Some software use small buffer sizes which can lead to more requests and therefore greater overhead. You can test this out yourself by replacing <code>bs=1M</code> in the examples below with <code>ibs</code> or <code>obs</code> and using a size of <code>512</code> instead of <code>1M</code>. In one example test using <code>nullrw</code> the write speed dropped from 4.9GB/s to 69.7MB/s when moving from <code>1M</code> to <code>512</code>. Similar results were had when testing reads. Small writes overhead may be improved by leveraging a write cache but in casual tests little gain was found. More tests will need to be done before this feature would become available. If you have an app that appears slow with mergerfs it could be due to this. Contact trapexit so he may investigate further.</p>"},{"location":"benchmarking/#write-benchmark","title":"write benchmark","text":"<pre><code>$ dd if=/dev/zero of=/mnt/mergerfs/1GB.file bs=1M count=1024 oflag=nocache conv=fdatasync status=progress\n</code></pre>"},{"location":"benchmarking/#read-benchmark","title":"read benchmark","text":"<pre><code>$ dd if=/mnt/mergerfs/1GB.file of=/dev/null bs=1M count=1024 iflag=nocache conv=fdatasync status=progress\n</code></pre>"},{"location":"benchmarking/#other-benchmarks","title":"other benchmarks","text":"<p>If you are attempting to benchmark other behaviors you must ensure you clear kernel caches before runs. In fact it would be a good deal to run before the read and write benchmarks as well just in case.</p> <pre><code>sync\necho 3 | sudo tee /proc/sys/vm/drop_caches\n</code></pre>"},{"location":"error_handling_and_logging/","title":"Error Handling and Logging","text":""},{"location":"error_handling_and_logging/#error-handling","title":"Error Handling","text":"<p>POSIX filesystem functions typically work on singular items and return singular errors. This means that there is some complication when dealing with multiple files or behaviors that are required in mergerfs.</p> <p>mergerfs tries to handle errors in a way that would generally return meaningful values for that particular function.</p>"},{"location":"error_handling_and_logging/#filesystem-functions","title":"Filesystem Functions","text":""},{"location":"error_handling_and_logging/#chmod-chown-removexattr-setxattr-truncate-utimens","title":"chmod, chown, removexattr, setxattr, truncate, utimens","text":"<ol> <li>if no errors: return 0 (success)</li> <li>if no successes: return first error</li> <li>if one of the files acted on was the same as the related search    function: return its value</li> <li>return 0 (success)</li> </ol> <p>While doing this increases the complexity and cost of error handling, particularly step 3, this provides probably the most reasonable return value.</p>"},{"location":"error_handling_and_logging/#unlink-rmdir","title":"unlink, rmdir","text":"<ol> <li>if no errors: return 0 (success)</li> <li>return first error</li> </ol> <p>Older versions of mergerfs would return success if any success occurred but for unlink and rmdir there are downstream assumptions that, while not impossible to occur in more traditional situation, can confuse some software.</p>"},{"location":"error_handling_and_logging/#open-create","title":"open, create","text":"<p>For <code>create</code> and <code>open</code> where a single file is targeted the return value of the equivalent final call is returned.</p> <p>If the error returned is <code>EROFS</code>, indicating the filesystem is in fact read-only, mergerfs will mark the branch <code>RO</code> and rerun the policy. This typically will only happen with <code>ext4</code> when the filesystem is found to have corruption and the OS remounts the filesystem as read-only to protect it. In that situation the filesystem does not otherwise indicate that it is read-only as it would if mounted with <code>ro</code>.</p>"},{"location":"error_handling_and_logging/#others","title":"others","text":"<p>For search functions, there is always a single thing acted on and as such whatever return value that comes from the single function call is returned.</p> <p>For create functions <code>mkdir</code>, <code>mknod</code>, and <code>symlink</code> which don't return a file descriptor and therefore can have <code>all</code> or <code>epall</code> policies it will return success if any of the calls succeed and an error otherwise.</p>"},{"location":"error_handling_and_logging/#branches-disappearing-reappearing","title":"Branches disappearing / reappearing","text":"<p>This is not an error condition. mergerfs works on paths. Not mounts. There is currently no assumption or active inspection of the branch path provided at runtime. Nor does it keep its own open file descriptors that would prevent an unused filesystem from being unmounted. If a filesystem disappears for any reason mergerfs will simply continue on behaving as it would normally. As if you never mounted that filesystem into that location. If a branch path no longer exists the branch is simply skipped by policies.</p> <p>If you wish to keep the branch path from being used when a branch path's intended filesystem disappears then make the directory difficult or impossible to use.</p> <pre><code>chown root:root /mnt/mountpoint/\nchmod 0000 /mnt/mountpoint/\nchattr +i /mnt/mountpoint/\n</code></pre> <p>You can still mount to that directory but you will not be able to write to it. Even as root. Note that <code>chattr</code> works on limited filesystems. Mainly <code>ext4</code>.</p>"},{"location":"error_handling_and_logging/#logging","title":"Logging","text":"<p>Filesystems, and therefore mergerfs, are doing lots of small actions at high speed. It simply isn't reasonable to log all the actions of the system. That said: certain details are logged at startup and when performing maintenance tasks. These are logged via <code>syslog</code> and on <code>systemd</code> based systems can be viewed by running</p> <pre><code>journalctl -t mergerfs\n</code></pre>"},{"location":"intro_to_filesystems/","title":"Intro to Filesystems","text":"<p>WORK IN PROGRESS</p> <p>mergerfs is a union filesystem that manages other filesystems. To understand how mergerfs works and what the features do and mean you must understand at least the basics of how filesystems work. Much of the confusion with mergerfs is based in a lack of knowledge about filesystems. This section of the documentation is provide a primer for those needing that knowledge.</p>"},{"location":"intro_to_filesystems/#terminology","title":"terminology","text":""},{"location":"intro_to_filesystems/#files","title":"files","text":""},{"location":"intro_to_filesystems/#types","title":"types","text":"<ul> <li>regular:</li> <li>directory:</li> <li>symlink:</li> <li>fifo:</li> <li>unix domain socket:</li> </ul>"},{"location":"intro_to_filesystems/#inodes","title":"inodes","text":""},{"location":"intro_to_filesystems/#names","title":"names","text":""},{"location":"intro_to_filesystems/#permissions","title":"permissions","text":""},{"location":"intro_to_filesystems/#owership","title":"owership","text":""},{"location":"intro_to_filesystems/#functions","title":"functions","text":""},{"location":"intro_to_filesystems/#workflows","title":"workflows","text":""},{"location":"intro_to_filesystems/#creating-a-file","title":"creating a file","text":""},{"location":"intro_to_filesystems/#reading-or-writing-to-a-file","title":"reading or writing to a file","text":""},{"location":"intro_to_filesystems/#copying-a-file","title":"copying a file","text":""},{"location":"intro_to_filesystems/#moving-a-file","title":"moving a file","text":""},{"location":"known_issues_bugs/","title":"Known Issues and Bugs","text":""},{"location":"known_issues_bugs/#mergerfs","title":"mergerfs","text":""},{"location":"known_issues_bugs/#supplemental-user-groups","title":"Supplemental user groups","text":"<p>Due to the overhead of getgroups/setgroups mergerfs utilizes a cache. This cache is opportunistic and per thread. Each thread will query the supplemental groups for a user when that particular thread needs to change credentials and will keep that data for the lifetime of the thread. This means that if a user is added to a group it may not be picked up without the restart of mergerfs. In the future this may be improved to allow a periodic or manual clearing of the cache.</p> <p>While not a bug some users have found when using containers that supplemental groups defined inside the container don't work as expected. Since mergerfs lives outside the container it is querying the host's group database. Effectively containers have their own user and group definitions unless setup otherwise just as different systems would.</p> <p>Users should mount in the host group file into the containers or use a standard shared user &amp; groups technology like NIS or LDAP.</p>"},{"location":"known_issues_bugs/#directory-mtime-is-not-being-updated","title":"directory mtime is not being updated","text":"<p>Remember that the default policy for <code>getattr</code> is <code>ff</code>. The information for the first directory found will be returned. If it wasn't the directory which had been updated then it will appear outdated.</p> <p>The reason this is the default is because any other policy would be more expensive and for many applications it is unnecessary. To always return the directory with the most recent mtime or a faked value based on all found would require a scan of all filesystems.</p> <p>If you always want the directory information from the one with the most recent mtime then use the <code>newest</code> policy for <code>getattr</code>.</p>"},{"location":"known_issues_bugs/#mv-mntpoolfoo-mntdisk1foo-removes-foo","title":"'mv /mnt/pool/foo /mnt/disk1/foo' removes 'foo'","text":"<p>This is not a bug.</p> <p>Run in verbose mode to better understand what's happening:</p> <pre><code>$ mv -v /mnt/pool/foo /mnt/disk1/foo\ncopied '/mnt/pool/foo' -&gt; '/mnt/disk1/foo'\nremoved '/mnt/pool/foo'\n$ ls /mnt/pool/foo\nls: cannot access '/mnt/pool/foo': No such file or directory\n</code></pre> <p><code>mv</code>, when working across devices, is copying the source to target and then removing the source. Since the source is the target in this case, depending on the unlink policy, it will remove the just copied file and other files across the branches.</p> <p>If you want to move files to one filesystem just copy them there and use mergerfs.dedup to clean up the old paths or manually remove them from the branches directly.</p>"},{"location":"known_issues_bugs/#cached-memory-appears-greater-than-it-should-be","title":"cached memory appears greater than it should be","text":"<p>Use <code>cache.files=off</code> and/or <code>dropcacheonclose=true</code>. See the section on page caching.</p>"},{"location":"known_issues_bugs/#3rd-party-software","title":"3rd Party Software","text":""},{"location":"known_issues_bugs/#nfs-clients-returning-estale-stale-file-handle","title":"NFS clients returning ESTALE / Stale file handle","text":"<p>NFS generally does not like out of band changes. Take a look at the section on NFS in the remote-filesystems for more details.</p>"},{"location":"known_issues_bugs/#sqlite3-plex-jellyfin-do-not-work-with-mergerfs","title":"SQLite3, Plex, Jellyfin do not work with mergerfs","text":"<p>It does. If you're trying to put the software's config / metadata / database on mergerfs you can't set cache.files=off (unless you use Linux v6.6 or above) because they are using sqlite3 with mmap enabled.</p> <p>That said it is recommended that config and runtime files be stored on SSDs on a regular filesystem for performance reasons. See What should mergerfs NOT be used for?.</p> <p>Other software that leverages sqlite3 which require mmap includes Radarr, Sonarr, and Lidarr. That said many programs use sqlite3 and do not require mmap.</p> <p>It is recommended that you reach out to the developers of the software you are having troubles with and asking them to add a fallback to regular file IO when mmap is unavailable. It is not only more compatible and resilient but also can be more performant in certain situations.</p> <p>If the issue is that quick scanning doesn't seem to pick up media then be sure to set <code>func.getattr=newest</code>. That said a full scan will pick up all media and it will put less load on the host to use time based library scans or to configure downloading software to trigger a scan when files are added to the pool. See Does inotify and fanotify work? for more details.</p>"},{"location":"known_issues_bugs/#my-32bit-software-has-problems","title":"my 32bit software has problems","text":"<p>Some software have problems with 64bit inode values. The symptoms can include EOVERFLOW errors when trying to list files. You can address this by setting <code>inodecalc</code> to one of the 32bit based algos as described in the relevant section.</p>"},{"location":"known_issues_bugs/#moving-files-and-directories-fails-with-samba","title":"Moving files and directories fails with Samba","text":"<p>Workaround: Copy the file/directory and then remove the original rather than move.</p> <p>This isn't an issue with Samba but some SMB clients. GVFS-fuse v1.20.3 and prior (found in Ubuntu 14.04 among others) failed to handle certain error codes correctly. Particularly <code>STATUS_NOT_SAME_DEVICE</code> which comes from the <code>EXDEV</code> that is returned by <code>rename</code> when the call is crossing mount points. When a program gets an <code>EXDEV</code> it needs to explicitly take an alternate action to accomplish its goal. In the case of <code>mv</code> or similar it tries <code>rename</code> and on <code>EXDEV</code> falls back to a copying the file to the destination and deleting the source. In these older versions of GVFS-fuse if it received <code>EXDEV</code> it would translate that into <code>EIO</code>. This would cause <code>mv</code> or most any application attempting to move files around on that SMB share to fail with a generic IO error.</p> <p>GVFS-fuse v1.22.0 and above fixed this issue but a large number of systems use the older release. On Ubuntu, the version can be checked by issuing <code>apt-cache showpkg gvfs-fuse</code>. Most distros released in 2015 seem to have the updated release and will work fine but older systems may not. Upgrading gvfs-fuse or the distro in general will address the problem.</p> <p>In Apple's MacOSX 10.9 they replaced Samba (client and server) with their own product. It appears their new client does not handle <code>EXDEV</code> either and responds similarly to older releases of gvfs on Linux.</p>"},{"location":"known_issues_bugs/#trashing-files-occasionally-fails","title":"Trashing files occasionally fails","text":"<p>This is the same issue as with Samba. <code>rename</code> returns <code>EXDEV</code> (in our case that will really only happen with path preserving policies like <code>epmfs</code>) and the software doesn't handle the situation well. This is unfortunately a common failure of software which moves files around. The standard indicates that an implementation MAY choose to support non-user home directory trashing of files (which is a MUST). The implementation MAY also support \"top directory trashes\" which many probably do.</p> <p>To create a <code>$topdir/.Trash</code> directory as defined in the standard use the mergerfs-tools tool <code>mergerfs.mktrash</code>.</p>"},{"location":"known_issues_bugs/#fuse-and-linux-kernel","title":"FUSE and Linux kernel","text":"<p>There have been a number of kernel issues / bugs over the years which mergerfs has run into. Here is a list of them for reference and posterity.</p>"},{"location":"known_issues_bugs/#nfs-and-eio-errors","title":"NFS and EIO errors","text":"<p>https://lore.kernel.org/linux-fsdevel/20240228160213.1988854-1-mszeredi@redhat.com/T/</p> <p>Over the years some users have reported that while exporting mergerfs via NFS, after significant filesystem activity, not only will the NFS client start returning ESTALE and EIO errors but mergerfs itself would start returning EIO errors. The problem was that no one could reliability reproduce the issue. After a string of reports in late 2023 and early 2024 more investigation was done.</p> <p>In Linux 5.14 new validation was put into FUSE which caught a few invalid situations and would tag a FUSE node as invalid if a check failed. Such checks include invalid file type, changing of type from one request to another, a size greater than 63bit, and the generation of a inode changing while in use.</p> <p>What happened was that mergerfs was using a different fixed, non-zero value for the generation of all nodes as it was suggested that unique inode + generation pairs are needed for proper integration with NFS. That non-zero value was being sent back to the kernel when a lookup request was made for root. The reason this was hard to track down was because NFS almost uniquely uses an API which can lead to a lookup of the root node that simply won't happen under normal workloads and usage. And that lookup will only happen if child nodes of the root were forgotten but NFS still had a handle to that node and later asked for details about it. It would trigger a set of requests to lookup info on those nodes.</p> <p>This wasn't a bug in FUSE but mergerfs. However, the incorrect behavior of mergerfs lead to FUSE behave in an unexpected and incorrect manner. It would issue a lookup of the \"parent of a child of the root\" and mergerfs would send the invalid generation value. As a result the kernel would mark the root node as \"bad\" which would then trigger the kernel to issue a \"forget root\" message. In between those it would issue a request for the parent of the root... which doesn't exist.</p> <p>So the kernel was doing two invalid things. Requesting the parent of the root and then when that failed issuing a forget for the root. These led to chasing after the wrong possible causes.</p> <p>The change was for FUSE to revert the marking of root node bad if the generation is non-zero and warn about it. It will mark the node bad but not unhash/forget/remove it.</p> <p>mergerfs in v2.40.1 ensures that generation for root is always 0 on lookup which should work across any kernel version.</p>"},{"location":"known_issues_bugs/#truncated-files","title":"Truncated files","text":"<p>This was a bug with <code>mmap</code> and <code>FUSE</code> on 32bit platforms. Should be fixed in all LTS releases.</p> <ul> <li>https://marc.info/?l=linux-fsdevel&amp;m=155550785230874&amp;w=2</li> </ul>"},{"location":"known_issues_bugs/#crashing-on-openvz","title":"Crashing on OpenVZ","text":"<p>There was a bug in the OpenVZ kernel with regard to how it handles <code>ioctl</code> calls. It was making invalid requests which would lead to crashes due to mergerfs not expecting them.</p> <ul> <li>https://bugs.openvz.org/browse/OVZ-7145</li> <li>https://www.mail-archive.com/devel@openvz.org/msg37096.html</li> </ul>"},{"location":"known_issues_bugs/#really-bad-mmap-performance","title":"Really bad mmap performance","text":"<p>There was a bug in caching which affects overall performance of <code>mmap</code> through <code>FUSE</code> in Linux 4.x kernels. It is fixed in 4.4.10 and 4.5.4.</p> <ul> <li>https://lkml.org/lkml/2016/3/16/260</li> <li>https://lkml.org/lkml/2016/5/11/59</li> </ul>"},{"location":"known_issues_bugs/#heavy-load-and-memory-pressure-leads-to-kernel-panic","title":"Heavy load and memory pressure leads to kernel panic","text":"<ul> <li>https://lkml.org/lkml/2016/9/14/527</li> <li>https://lkml.org/lkml/2016/10/4/1</li> <li>https://www.theregister.com/2016/10/05/linus_torvalds_admits_buggy_crap_made_it_into_linux_48/</li> </ul>"},{"location":"media_and_publicity/","title":"Media and Publicity","text":""},{"location":"media_and_publicity/#tutorials-articles","title":"Tutorials / Articles","text":"<ul> <li>2016-02-02 - Linuxserver.io: The Perfect Media Server 2016</li> <li>2016-08-31 - ZackReed.me: Mergerfs \u2013 another good option to pool your SnapRAID disks</li> <li>2016-11-06 - Linuxserver.io: Revisiting the HP ProLiant Gen8 G1610T Microserver</li> <li>2017-01-17 - Setting up mergerfs on JBOD's (or a poor mans storage array)</li> <li>2017-06-24 - Linuxserver.io: The Perfect Media Server 2017</li> <li>2018-02-19 - Teknophiles: Disk Pooling in Linux with mergerFS</li> <li>2018-02-20 - Fortes.com: Using Rclone and MergerFS together across drives</li> <li>2019-02-10 - Medium: Migrating from ZFS to MergerFS and SnapRAID at home</li> <li>2019-04-24 - MichaelXander.com: DIY NAS with OMV, SnapRAID, MergerFS, and Disk Encryption</li> <li>2019-07-16 - Linuxserver.io: The Perfect Media Server - 2019 Edition</li> <li>2019-09-10 - Rclone VFS and MergerFS Setup</li> <li>2019-12-20 - NetworkShinobi.com: SnapRAID and MergerFS on OpenMediaVault</li> <li>2020-01-14 - Brandon Rozek's Blog</li> <li>2020-02-14 - SelfHostedHome.com: Combining Different Sized Drives with mergerfs and SnapRAID</li> <li>2020-05-01 - FedoraMagazine.org: Using mergerfs to increase your virtual storage</li> <li>2020-08-20 - Setting up Rclone, Mergerfs and Crontab for automated cloud storage</li> <li>2020-11-22 - Introducing\u2026 MergerFS \u2013 My FREE UNRAID alternative</li> <li>2020-12-30 - Perfect Media Server (a new site with docs fully fleshing out the 'Perfect Media Server' blog series)</li> <li>2021-07-24 - Building the Ultimate Linux Home Server - Part 1: Intro, MergerFS, and SnapRAID</li> <li>2021-10-31 - Better Home Storage: MergerFS + SnapRAID on OpenMediaVault</li> <li>2021-11-28 - Linux Magazine: Come Together - Merging file systems for a simple NAS with MergerFS</li> <li>2022-06-04 - MergerFS + SnapRaid Study</li> <li>2022-12-31 - Merge Storages in CasaOS: A secret beta feature you know now</li> <li>2023-02-03 - (MergerFS + SnapRAID) is the new RAID 5</li> <li>2024-02-07 - Designing &amp; Deploying MANS - A Hybrid NAS Approach with SnapRAID, MergerFS, and OpenZFS</li> <li>2024-03-11 - Using MergerFS to combine multiple hard drives into one unified media storage</li> <li>2024-12-20 - Pooling multiple drives on my Raspberry Pi with mergerfs</li> </ul>"},{"location":"media_and_publicity/#videos","title":"Videos","text":"<ul> <li>2017-06-23 - Alex Kretzschmar: Part 1 - Perfect Media Server 2017 - Introduction</li> <li>2017-06-24 - Alex Kretzschmar: Part 2 - Perfect Media server 2017 - Installing Debian 9 Stretch</li> <li>2017-06-24 - Alex Kretzschmar: Part 3 - Perfect Media Server 2017 - Install MergerFS and setting up your drives</li> <li>2017-06-24 - Alex Kretzschmar: Part 4 - Perfect Media Server 2017 - Installing Docker</li> <li>2017-06-24 - Alex Kretzschmar: Part 5 - Perfect Media Server 2017 - Installing and Automating SnapRAID</li> <li>2017-06-24 - Alex Kretzschmar: Part 6 - Perfect Media Server 2017 -Turning your server into a NAS with Samba and NFS</li> <li>2017-06-24 - Alex Kretzschmar: Part 7 - Perfect Media Server 2017 - Managing your apps with docker-compose</li> <li>2017-06-24 - Alex Kretzschmar: Part 8 - Perfect Media Server 2017 - Manging your server using a web UI (Cockpit and Portainer)</li> <li>2018-04-24 - ElectronicsWizardy: How to setup a Linux Fileserver with Snapraid and Mergerfs Re-Export</li> <li>2019-03-01 - Snapraid and Unionfs: Advanced Array Options on Openmediavault (Better than ZFS and Unraid)</li> <li>2019-03-22 - Gamexplicit: The Perfect Plex Media Server 2019! Part 1 (Hardware)</li> <li>2019-05-13 - Gamexplicit: The Perfect Plex Media Server 2019! Part 2 (Ubuntu Server 18.04.2 LTS)</li> <li>2019-05-20 - Gamexplicit: The Perfect Plex Media Server 2019! Part 3 (SnapRaid, Samba, Plex)</li> <li>2020-08-23 - Installing OpenMediaVault and SnapRAID and UnionFS (mergerfs)</li> <li>2021-06-07 - I ditched TrueNAS for MergerFS - Chia Plot Storage</li> <li>2021-08-03 - Install and configure mergerfs to merge more than one folder in the same place</li> <li>2021-08-10 - Instalando e configurando mergerfs para unir mais de uma pasta no mesmo lugar</li> <li>2021-08-13 - Let's Convert an Old Laptop to a NAS - What you should do</li> <li>2021-08-17 - How to Combine Multiple Disks as One by using MergerFS | Ubuntu 20.04 LTS</li> <li>2021-08-20 - Vamos converter um Laptop antigo para um NAS \u2013 O que voc\u00ea deve fazer</li> <li>2021-10-29 - Unlimited space for your Plex using Rclone to connect to your Cloud</li> <li>2022-12-01 - Make Your Home Server Go FAST! SSD Caching, 10Gbit Networking, etc.</li> <li>2022-12-07 - Best RAID for mixed drive sizes. Unraid vs BTRFS vs Snapraid+Mergerfs vs Storage spaces.</li> <li>2023-02-21 - MergerFS + SnapRAID : Forget about RAID 5 in your Home Server !</li> <li>2023-06-26 - How to install and setup MergerFS</li> <li>2023-07-31 - How to recover a dead drive using Snapraid</li> <li>2024-01-05 - OpenMediaVault MergerFS Tutorial (Portuguese)</li> <li>2024-02-19 - Setup and Install MergerFS and SnapRAID (Part 1)</li> <li>2024-02-22 - Setup and Install MergerFS and SnapRAID (Part 2)</li> <li>2024-11-15 - Meu servidor NAS - Parte 18: Recuperando um HD, recuperando o MergerFS e os pr\u00f3ximos passos do NAS!</li> <li>2025-04-23 - How to build the Perfect Media Server | Part 1 - The Tech Stack | mergerfs, SnapRAID, and docker.</li> </ul>"},{"location":"media_and_publicity/#podcasts","title":"Podcasts","text":"<ul> <li>2019-11-04 - Jupiter Extras: A Chat with mergerfs Developer Antonio Musumeci | Jupiter Extras 28</li> <li>2019-11-07 - Jupiter Broadcasting: ZFS Isn\u2019t the Only Option | Self-Hosted 5</li> <li>2023-10-08 - Self Hosted Episode 105 - Sleeper Storage Technology</li> </ul>"},{"location":"media_and_publicity/#social-media","title":"Social Media","text":"<ul> <li>Reddit</li> <li>X</li> <li>YouTube</li> <li>ServeTheHome Forum</li> </ul>"},{"location":"performance/","title":"Tweaking Performance","text":"<p>mergerfs is at its is a proxy and therefore its theoretical max performance is that of the underlying devices. However, given it is a FUSE based filesystem working from userspace there is an increase in overhead relative to kernel based solutions. That said the performance can match the theoretical max but it depends greatly on the system's configuration. Especially when adding network filesystems into the mix there are many variables which can impact performance. Device speeds and latency, network speeds and latency, concurrency and parallel limits of the hardware, read/write sizes, etc.</p> <p>While some settings can impact performance they are all functional in nature. Meaning they change mergerfs' behavior in some way. As a result there is no such thing as a \"performance mode\".</p> <p>If you're having performance issues please look over the suggestions below and the benchmarking section.</p> <p>NOTE: Be sure to read about these features before changing them to understand how functionality will change.</p> <ul> <li>test theoretical performance using <code>nullrw</code> or mounting a ram disk</li> <li>change read or process thread pools</li> <li>change func.readdir</li> <li>increase readahead: <code>readahead=1024</code></li> <li>disable <code>security_capability</code> and/or <code>xattr</code></li> <li>increase cache timeouts cache.attr,   cache.entry,   cache.negative_entry</li> <li>enable (or disable) page caching (cache.files)</li> <li>enable <code>parallel-direct-writes</code></li> <li>enable cache.writeback</li> <li>enable cache.statfs</li> <li>enable cache.symlinks</li> <li>enable cache.readdir</li> <li>disable <code>posix_acl</code></li> <li>disable <code>async_read</code></li> <li>use symlinkify if your data is largely   static and read-only</li> <li>use tiered cache devices</li> <li>use LVM and LVM cache to place a SSD in front of your HDDs</li> </ul> <p>If you come across a setting that significantly impacts performance please contact trapexit so he may investigate further. Please test both against your normal setup, a singular branch, and with <code>nullrw=true</code></p>"},{"location":"project_comparisons/","title":"Project Comparisons","text":""},{"location":"project_comparisons/#mhddfs","title":"mhddfs","text":"<ul> <li>https://romanrm.net/mhddfs</li> </ul> <p>mhddfs had not been updated in over a decade and has known stability and security issues. mergerfs provides a super set of mhddfs' features and offers better performance. In fact, as of 2020, the author of mhddfs has moved to using mergerfs.</p> <p>Below is an example of mhddfs and mergerfs setup to work similarly.</p> <p><code>mhddfs -o mlimit=4G,allow_other /mnt/drive1,/mnt/drive2 /mnt/pool</code></p> <p><code>mergerfs -o minfreespace=4G,category.create=ff /mnt/drive1:/mnt/drive2 /mnt/pool</code></p>"},{"location":"project_comparisons/#aufs","title":"aufs","text":"<ul> <li>https://aufs.sourceforge.net</li> <li>https://en.wikipedia.org/wiki/Aufs</li> </ul> <p>While aufs still is maintained it failed to be included in the mainline kernel and is no longer available in most Linux distros making it harder to get installed for the average user.</p> <p>While aufs can often offer better peak performance due to being primarily kernel based, mergerfs provides more configurability and is generally easier to use. mergerfs however does not offer the overlay / copy-on-write (CoW) features which aufs has.</p>"},{"location":"project_comparisons/#unionfs","title":"unionfs","text":"<ul> <li>https://unionfs.filesystems.org</li> </ul> <p>unionfs for Linux is a \"stackable unification file system\" which functions like many other union filesystems. unionfs has not been maintained and was last released for Linux v3.14 back in 2014.</p> <p>Documentation is sparse so a comparison of features is not possible but given the lack of maintenance and support for modern kernels there is little reason to consider it as a solution.</p>"},{"location":"project_comparisons/#unionfs-fuse","title":"unionfs-fuse","text":"<ul> <li>https://github.com/rpodgorny/unionfs-fuse</li> </ul> <p>unionfs-fuse is more like unionfs, aufs, and overlayfs than mergerfs in that it offers overlay / copy-on-write (CoW) features. If you're just looking to create a union of filesystems and want flexibility in file/directory placement then mergerfs offers that whereas unionfs-fuse is more for overlaying read/write filesystems over read-only ones.</p> <p>Since unionfs-fuse, as the name suggests, is a FUSE based technology it can be used without elevated privileges that kernel solutions such as unionfs, aufs, and overlayfs require.</p>"},{"location":"project_comparisons/#overlayfs","title":"overlayfs","text":"<ul> <li>https://docs.kernel.org/filesystems/overlayfs.html</li> </ul> <p>overlayfs is effectively the successor to unionfs, unionfs-fuse, and aufs and is widely used by Linux container platforms such as Docker and Podman. It was developed and is maintained by the same developer who created FUSE.</p> <p>If your use case is layering a writable filesystem on top of read-only filesystems then you should look first to overlayfs. Its feature set however is very different from mergerfs and solve different problems.</p>"},{"location":"project_comparisons/#raid0-jbod-span-drive-concatenation-striping","title":"RAID0, JBOD, SPAN, drive concatenation, striping","text":"<ul> <li>RAID0</li> <li>JBOD</li> <li>SPAN</li> <li>striping</li> </ul> <p>These are block device technologies which in some form aggregate devices into what appears to be a singular device on which a traditional filesystem can be used. The filesystem has no understanding of the underlying block layout and should one of those underlying devices fail or be removed the filesystem will be missing that chunk which could contain critical information and the whole filesystem may become unrecoverable. Even if the data from the filesystem is recoverable it will take using specialized tooling to do so.</p> <p>In contrast, with mergerfs you can format devices as one normally would or take existing filesystems and then combine them in a pool to aggregate their storage. The failure of any one device will have no impact on the other devices. The downside to mergerfs' technique is the fact you don't actually have contiguous space as large as if you used those other technologies. Meaning you can't create a file greater than 1TB on a pool of 2 1TB filesystems.</p>"},{"location":"project_comparisons/#btrfs-single-data-profile","title":"BTRFS Single Data Profile","text":"<p>BTRFS' <code>single</code> data profile is similar to RAID0 but BTRFS can more explicitly place data and metadata on multiple devices. However, like RAID0 and similar technologies if a single device fails you may lose all data in the pool. BTRFS does have some abilities to recover data but this is not guaranteed.</p>"},{"location":"project_comparisons/#raid5-raid6","title":"RAID5, RAID6","text":"<ul> <li>RAID5</li> <li>RAID6</li> </ul> <p>mergerfs offers no parity or redundancy features so in that regard the technologies are not comparable. SnapRAID can be used in combination with mergerfs to provide redundancy. Unlike traditional RAID5 or RAID6 SnapRAID works with drives of different sizes and can have more than 2 parity drives. However, parity calculations are not done in real-time.</p> <p>See https://www.snapraid.it/compare for more details and comparisons.</p>"},{"location":"project_comparisons/#unraid","title":"UnRAID","text":"<ul> <li>https://unraid.net</li> </ul> <p>UnRAID is a full OS and offers a (FUSE based?) filesystem which provides a union of filesystems like mergerfs but with the addition of live parity calculation and storage. Outside parity calculations mergerfs offers more features and due to the lack of real-time parity calculation can have higher peak performance. Some users also prefer an open source solution.</p> <p>For semi-static data mergerfs + SnapRAID provides a similar, but not real-time, solution.</p>"},{"location":"project_comparisons/#zfs","title":"ZFS","text":"<ul> <li>https://en.wikipedia.org/wiki/ZFS</li> </ul> <p>mergerfs is very different from ZFS. mergerfs is intended to provide flexible pooling of arbitrary filesystems (local or remote), of arbitrary sizes, and arbitrary filesystems. Particularly in <code>write once, read many</code> use cases such as bulk media storage. Where data integrity and backup is managed in other ways. In those use cases ZFS can introduce a number of costs and limitations as described here, here, and here.</p>"},{"location":"project_comparisons/#stablebits-drivepool","title":"StableBit's DrivePool","text":"<ul> <li>https://stablebit.com</li> </ul> <p>DrivePool works only on Windows so not as common an alternative as other Linux solutions. If you want to use Windows then DrivePool is a good option. Functionally the two projects work a bit differently. DrivePool always writes to the filesystem with the most free space and later rebalances. mergerfs does not currently offer rebalance but chooses a branch at file/directory create time. DrivePool's rebalancing can be done differently in any directory and has file pattern matching to further customize the behavior. mergerfs, not having rebalancing does not have these features, but similar features are planned for mergerfs v3. DrivePool has builtin file duplication which mergerfs does not natively support (but can be done via an external script.)</p> <p>There are a lot of misc differences between the two projects but most features in DrivePool can be replicated with external tools in combination with mergerfs.</p> <p>Additionally, DrivePool is a closed source commercial product vs mergerfs a ISC licensed open source project.</p>"},{"location":"project_comparisons/#plan9-binds","title":"Plan9 binds","text":"<ul> <li>https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#Union_directories_and_namespaces</li> </ul> <p>Plan9 has the native ability to bind multiple paths/filesystems together to create a setup similar to simplified union filesystem. Such bind mounts choose files in a \"first found\" in the order they are listed similar to mergerfs' <code>ff</code> policy. Similar, when creating a file it will be created on the first directory in the union.</p> <p>Plan 9 isn't a widely used OS so this comparison is mostly academic.</p>"},{"location":"project_comparisons/#snapraid-pooling","title":"SnapRAID pooling","text":"<p>SnapRAID has a pooling feature which creates \"a read-only virtual view of all the files in your array using symbolic links.\"</p> <p>As mentioned in the description this \"view\" is just the creation of the same directory layout with symlinks to all files. This means that reads (and writes) to files are at native speeds but limited in that it can not practically be used as a target for writing new files and is only updated when <code>snapraid pool</code> is run. Note that some software treat symlinks differently than regular files. For instance some backup software will skip symlinks by default.</p> <p>mergerfs has the feature symlinkify which provides a similar behavior but is more flexible in that it is not read-only. That said there can still be some software that won't like that kind of setup.</p>"},{"location":"quickstart/","title":"QuickStart","text":""},{"location":"quickstart/#install","title":"Install","text":"<p>First ensure you have the latest version installed.</p>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>mergerfs has many options and effectively all of them are functional in nature. What that means is that there is no \"best\" or \"fastest\" configuration. No \"make faster\" options. Everything changes behavior. Sometimes those changes in behavior affect performance.</p> <p>If you don't already know that you have special requirements then use one of the following option sets as it will cover the common use cases.</p>"},{"location":"quickstart/#you-use-linux-v66-or-above","title":"You use Linux v6.6 or above","text":"<ul> <li>cache.files=off</li> <li>category.create=pfrd</li> <li>func.getattr=newest</li> <li>dropcacheonclose=false</li> </ul> <p>In previous versions of Linux it was unable to support <code>mmap</code> if page caching was disabled (ie: <code>cache.files=off</code>). However, it now will enable page caching if needed for a particular file if <code>mmap</code> is requested.</p> <p><code>mmap</code> is needed by certain software to read and write to a file. However, many software could work without it and fail to have proper error handling. Many programs that use sqlite3 will require <code>mmap</code> despite sqlite3 working perfectly fine without it (and in some cases can be more performant with regular file IO.)</p>"},{"location":"quickstart/#you-use-linux-v65-or-below","title":"You use Linux v6.5 or below","text":""},{"location":"quickstart/#you-need-mmap-used-by-rtorrent-and-many-sqlite3-base-software","title":"You need <code>mmap</code> (used by rtorrent and many sqlite3 base software)","text":"<ul> <li>cache.files=auto-full</li> <li>category.create=pfrd</li> <li>func.getattr=newest</li> <li>dropcacheonclose=true</li> </ul>"},{"location":"quickstart/#you-dont-need-mmap","title":"You don't need <code>mmap</code>","text":"<ul> <li>cache.files=off</li> <li>category.create=pfrd</li> <li>func.getattr=newest</li> <li>dropcacheonclose=false</li> </ul>"},{"location":"quickstart/#usage","title":"Usage","text":"<p>For some suggestions on branch setup see the page on branches.</p>"},{"location":"quickstart/#command-line","title":"Command Line","text":"<pre><code>mergerfs -o cache.files=off,category.create=pfrd,func.getattr=newest,dropcacheonclose=false /mnt/hdd0:/mnt/hdd1 /media\n</code></pre>"},{"location":"quickstart/#etcfstab","title":"/etc/fstab","text":"<pre><code>/mnt/hdd0:/mnt/hdd1 /media mergerfs cache.files=off,category.create=pfrd,func.getattr=newest,dropcacheonclose=false 0 0\n</code></pre>"},{"location":"quickstart/#etcfstab-w-config-file","title":"/etc/fstab w/ config file","text":"<p>For more complex setups it can be useful to separate out the config.</p>"},{"location":"quickstart/#etcfstab_1","title":"/etc/fstab","text":"<pre><code>/etc/mergerfs/branches/media/* /media mergerfs config=/etc/mergerfs/config/media.ini\n</code></pre>"},{"location":"quickstart/#etcmergerfsconfigmediaini","title":"/etc/mergerfs/config/media.ini","text":"media.ini<pre><code>cache.files=off\ncategory.create=pfrd\nfunc.getattr=newest\ndropcacheonclose=false\n</code></pre>"},{"location":"quickstart/#etcmergerfsbranchesmedia","title":"/etc/mergerfs/branches/media/","text":"<p>Create a bunch of symlinks to point to the branch. mergerfs will resolve the symlinks and use the real path.</p> <p><code>ls -lh /etc/mergerfs/branches/media/*</code></p> <pre><code>lrwxrwxrwx 1 root root 21 Aug  4  2023 hdd00 -&gt; /mnt/hdd/hdd00\nlrwxrwxrwx 1 root root 21 Aug  4  2023 hdd01 -&gt; /mnt/hdd/hdd01\nlrwxrwxrwx 1 root root 21 Aug  4  2023 hdd02 -&gt; /mnt/hdd/hdd02\nlrwxrwxrwx 1 root root 21 Aug  4  2023 hdd03 -&gt; /mnt/hdd/hdd03\n</code></pre>"},{"location":"quickstart/#systemd-simple","title":"systemd (simple)","text":"<p><code>/etc/systemd/system/mergerfs-media.service</code></p> mergerfs-media.service<pre><code>[Unit]\nDescription=mergerfs /media service\nAfter=local-fs.target network.target\n\n[Service]\nType=simple\nKillMode=none\nExecStart=/usr/bin/mergerfs \\\n  -f \\\n  -o cache.files=off \\\n  -o category.create=pfrd \\\n  -o func.getattr=newest \\\n  -o dropcacheonclose=false \\\n  /mnt/hdd0:/mnt/hdd1 \\\n  /media\nExecStop=/bin/fusermount -uz /media\nRestart=on-failure\n\n[Install]\nWantedBy=default.target\n</code></pre>"},{"location":"quickstart/#systemd-w-setup-script","title":"systemd (w/ setup script)","text":"<p>Since it isn't well documented otherwise: if you wish to do some setup before you mount mergerfs follow this example.</p>"},{"location":"quickstart/#setup-for-mergerfs","title":"setup-for-mergerfs","text":"<p><code>/usr/local/bin/setup-for-mergerfs</code></p> setup-for-mergerfs<pre><code>#!/usr/bin/env sh\n\n# Perform setup\n/bin/sleep 10\n\n# Report back to systemd that things are ready\n/bin/systemd-notify --ready\n</code></pre>"},{"location":"quickstart/#setup-for-mergerfsservice","title":"setup-for-mergerfs.service","text":"<p><code>/etc/systemd/system/setup-for-mergerfs.service</code></p> setup-for-mergerfs.service<pre><code>[Unit]\nDescription=mergerfs setup service\n\n[Service]\nType=notify\nRemainAfterExit=yes\nExecStart=/usr/local/bin/setup-for-mergerfs\n\n[Install]\nWantedBy=default.target\n</code></pre>"},{"location":"quickstart/#mergerfs-mediaservice","title":"mergerfs-media.service","text":"<p><code>/etc/systemd/system/mergerfs-media.service</code></p> mergerfs-media.service<pre><code>[Unit]\nDescription=mergerfs /media service\nRequires=setup-for-mergerfs.service\nAfter=local-fs.target network.target prepare-for-mergerfs.service\n\n[Service]\nType=simple\nKillMode=none\nExecStart=/usr/bin/mergerfs \\\n  -f \\\n  -o cache.files=off \\\n  -o category.create=pfrd \\\n  -o func.getattr=newest \\\n  -o dropcacheonclose=false \\\n  /mnt/hdd0:/mnt/hdd1 \\\n  /media\nExecStop=/bin/fusermount -uz /media\nRestart=on-failure\n\n[Install]\nWantedBy=default.target\n</code></pre>"},{"location":"related_projects/","title":"Related Projects","text":""},{"location":"related_projects/#projects-using-mergerfs","title":"Projects using mergerfs","text":"<ul> <li>Lakka.tv: A turnkey software emulation Linux   distribution. Used to pool user and local storage. Also includes my   other project Opera. A 3DO emulator.</li> <li>OpenMediaVault: A network attached   storage (NAS) solution based on Debian Linux. They provide plugins   to manage mergerfs.</li> <li>CasaOS: \"A simple, easy to use, elegant open   source home cloud system.\" Has added initial integration with   mergerfs to create pools from existing filesystems.</li> <li>ZimaOS: A more   commercially focused NAS OS by the authors of CasaOS at Ice   Whale.</li> <li>Cosmos Cloud: Cosmos \"take the chore out   of selfhosting, with automated maintenance and fully secured setup   out of the box. It even integrates to your existing setup.\"</li> </ul>"},{"location":"related_projects/#software-and-services-commonly-used-with-mergerfs","title":"Software and services commonly used with mergerfs","text":"<ul> <li>snapraid: a backup program designed for   disk arrays, storing parity information for data recovery in the   event of up to six disk failures.</li> <li>rclone: a command-line program to manage   files on cloud storage. It is a feature-rich alternative to cloud   vendors' web storage interfaces. rclone's   union feature is based on mergerfs   policies.</li> <li>ZFS: A popular filesystem and volume   management platform originally part of Sun Solaris and later ported   to other operating systems. It is common to use ZFS with   mergerfs. ZFS for important data and mergerfs pool for replacable   media.</li> <li>Proxmox: Proxmox is a popular, Debian   based, virtualization platform. Users tend to install mergerfs on   the host and pass the mount into containers.</li> <li>UnRAID: \"Unraid is a powerful, easy-to-use   operating system for self-hosted servers and network-attached   storage.\" While UnRAID has its own union filesystem it isn't   uncommon to see UnRAID users leverage mergerfs given the differences   in the technologies. There is a plugin available by   Rysz   to ease installation and setup.</li> <li>TrueNAS SCALE: An   enterprise focused NAS operating system with OpenZFS support. A Some   users are requesting mergerfs be made part   of   TrueNAS.</li> <li>For a time there were a number of Chia miners recommending mergerfs.</li> <li>cloudboxes.io: VPS provider. Includes   details on their   wiki:   on how to setup mergerfs.</li> <li>QNAP: A company   known for their turnkey, consumer focused NAS devices. Someone has   created builds of mergerfs for different QNAP devices.</li> </ul>"},{"location":"related_projects/#distributions-including-mergerfs","title":"Distributions including mergerfs","text":"<p>mergerfs can be found in the repositories of many Linux distributions and FreeBSD.</p> <p>Note: Any non-rolling release based distro is likely to have out-of-date versions.</p> <ul> <li>Debian</li> <li>Ubuntu</li> <li>Fedora</li> <li>T2</li> <li>Alpine</li> <li>Gentoo</li> <li>Arch (AUR)</li> <li>Void</li> <li>NixOS</li> <li>Guix</li> <li>Slackware</li> <li>FreeBSD</li> </ul>"},{"location":"remote_filesystems/","title":"Remote Filesystems","text":"<p>This section is to describe any known issues or quirks when using mergerfs with common remote filesystems.</p> <p>There are two ways to use mergerfs with a network filesystem. One is to use it within the pool as a branch and one is the exporting of a mergerfs mount.</p>"},{"location":"remote_filesystems/#general-notes","title":"General Notes","text":""},{"location":"remote_filesystems/#do-not-change-things-out-of-band","title":"Do not change things out-of-band","text":"<p>Keep in mind that, like when using caching, it is NOT a good idea to change the contents of the remote filesystem out-of-band. Meaning that you should not change the contents of the underlying filesystems or mergerfs on the server hosting the remote filesystem. Files should exclusively be interacted with through the network filesystem. Doing otherwise can lead to weird behavior, inconsistency, errors, and even data corruption should multiple programs try to write or read the same data at the same time. This isn't to say you can't do it or that data corruption is likely but it could happen. If you're only reading from those filesystems there is little risk but writing or modifying file layout will be a problem. Particularly with NFS. It is better to always use the remote filesystem. Even on the machine serving it.</p>"},{"location":"remote_filesystems/#nfs","title":"NFS","text":"<p>NFS is a common remote filesystem on Unix/POSIX systems. Due to how NFS works there are some settings which need to be set in order for mergerfs to work with it.</p>"},{"location":"remote_filesystems/#nfs-as-branch","title":"NFS as branch","text":"<p>mergerfs settings:</p> <ul> <li>No special settings need to be set</li> </ul> <p>NFS export settings:</p> <ul> <li><code>no_root_squash</code>: mergerfs must be able to make requests that only   root is permissioned to make. If any root squashing occurs, just as   running mergerfs as a non-root user, there is no guarantee that   mergerfs will be able to do what it needs to manage the underlying   filesystem.</li> </ul>"},{"location":"remote_filesystems/#nfs-exporting-mergerfs","title":"NFS exporting mergerfs","text":"<p>It should be noted that NFS and FUSE (the technology mergerfs uses) do not work perfectly with one another. They largely can be worked around but if you run into problems it may be worth trying Samba/SMB.</p> <p>mergerfs settings:</p> <ul> <li><code>noforget</code></li> <li><code>inodecalc=path-hash</code></li> </ul> <p><code>noforget</code> is needed because NFS uses the <code>name_to_handle_at</code> and <code>open_by_handle_at</code> functions which allow a program to keep a reference to a file without technically having it open in the typical sense. The problem is that FUSE has no way to know that NFS has a handle that it will later use to open the file again. As a result, it is possible for the kernel to tell mergerfs to forget about the file node and should NFS ever ask for that node's details in the future it would have nothing to respond with. Keeping nodes around forever is not ideal but at the moment the only way to manage the situation.</p> <p><code>inodecalc=path-hash</code> is needed because NFS is sensitive to out-of-band changes. FUSE doesn't care if a file's inode value changes but NFS, being stateful, does. So if you used the default inode calculation algorithm it is possible that if you changed a file or updated a directory the file mergerfs will use will be on a different branch and therefore the inode would change. This isn't an ideal solution and others are being considered but it works for most situations.</p> <p>NFS export settings:</p> <ul> <li><code>fsid=UUID</code></li> <li><code>no_root_squash</code></li> </ul> <p><code>fsid=UUID</code> is needed because FUSE filesystems don't have different <code>st_dev</code> values which can cause issues when exporting. The easiest thing to do is set each mergerfs export <code>fsid</code> to some random value. An easy way to generate a random value is to use the command line tool <code>uuid</code> or <code>uuidgen</code> or through a website such as uuidgenerator.net.</p> <p><code>no_root_squash</code> is required for the same reason mergerfs needs to run as <code>root</code>. Certain behaviors of mergerfs require control over the filesystem that only <code>root</code> can preform. If squashing is enabled, or mergerfs was running as non-root, it would be unable to perform certain function and you will receive permission errors.</p>"},{"location":"remote_filesystems/#smb-cifs","title":"SMB / CIFS","text":"<p>SMB is a protocol most used by Microsoft Windows systems to share file shares, printers, etc. However, due to the popularity of Windows, it is also supported on many other platforms including Linux. The most popular way of supporting SMB on Linux is via the software Samba.</p>"},{"location":"remote_filesystems/#smb-as-branch","title":"SMB as branch","text":"<p>Using a SMB mount as a branch in mergerfs may result in problems (permission errors) since it is not POSIX compliant. This setup is not common and has not been extensively tested.</p>"},{"location":"remote_filesystems/#smb-exporting-mergerfs","title":"SMB exporting mergerfs","text":"<p>Samba and other ways of serving Linux filesystems via SMB should work fine with mergerfs. The services do not tend to use the same technologies which NFS uses and therefore don't have the same issues. There should not be special settings required export mergerfs with Samba. However, CIFSD and other programs have not been extensively tested. If you use mergerfs with CIFSD or other SMB servers please submit your experiences so these docs can be updated.</p>"},{"location":"remote_filesystems/#sshfs","title":"SSHFS","text":"<p>SSHFS is a FUSE filesystem leveraging SSH as the connection and transport layer. While often simpler to setup when compared to NFS or Samba the performance can be lacking and the project is very much in maintenance mode.</p> <p>There are no known issues using sshfs with mergerfs. You may want to use the following arguments to improve performance but your millage may vary.</p> <ul> <li><code>-o Ciphers=arcfour</code></li> <li><code>-o Compression=no</code></li> </ul> <p>More info can be found here.</p>"},{"location":"remote_filesystems/#other","title":"Other","text":"<p>There are other remote filesystems but none popularly used to serve mergerfs. If you use something not listed above feel free to reach out and I will add it to the list.</p>"},{"location":"runtime_interfaces/","title":"Runtime Interfaces","text":""},{"location":"runtime_interfaces/#runtime-config","title":"Runtime Config","text":""},{"location":"runtime_interfaces/#mergerfs-pseudo-file","title":".mergerfs pseudo file","text":"<pre><code>&lt;mountpoint&gt;/.mergerfs\n</code></pre> <p>There is a pseudo file available at the mount point which allows for the runtime modification of certain mergerfs options. The file will not show up in readdir but can be stat'ed and manipulated via {list,get,set}xattrs calls.</p> <p>Any changes made at runtime are not persisted. If you wish for values to persist they must be included as options wherever you configure the mounting of mergerfs (/etc/fstab).</p>"},{"location":"runtime_interfaces/#keys","title":"Keys","text":"<p>Use <code>getfattr -d /mountpoint/.mergerfs</code> or <code>xattr -l /mountpoint/.mergerfs</code> to see all supported keys. Some are informational and therefore read-only. <code>setxattr</code> will return EINVAL (invalid argument) on read-only keys.</p>"},{"location":"runtime_interfaces/#values","title":"Values","text":"<p>Same as the command line.</p>"},{"location":"runtime_interfaces/#usermergerfsbranches","title":"user.mergerfs.branches","text":"<p>Used to query or modify the list of branches. When modifying there are several shortcuts to easy manipulation of the list.</p> Value Description [list] set +&lt;[list] prepend +&gt;[list] append -[list] remove all values provided -&lt; remove first in list -&gt; remove last in list <p><code>xattr -w user.mergerfs.branches +&lt;/mnt/drive3 /mnt/pool/.mergerfs</code></p> <p>The <code>=NC</code>, <code>=RO</code>, <code>=RW</code> syntax works just as on the command line.</p>"},{"location":"runtime_interfaces/#example","title":"Example","text":"<pre><code>[trapexit:/mnt/mergerfs] $ getfattr -d .mergerfs\nuser.mergerfs.branches=\"/mnt/a=RW:/mnt/b=RW\"\nuser.mergerfs.minfreespace=\"4294967295\"\nuser.mergerfs.moveonenospc=\"false\"\n...\n\n[trapexit:/mnt/mergerfs] $ getfattr -n user.mergerfs.category.search .mergerfs\nuser.mergerfs.category.search=\"ff\"\n\n[trapexit:/mnt/mergerfs] $ setfattr -n user.mergerfs.category.search -v newest .mergerfs\n[trapexit:/mnt/mergerfs] $ getfattr -n user.mergerfs.category.search .mergerfs\nuser.mergerfs.category.search=\"newest\"\n</code></pre>"},{"location":"runtime_interfaces/#file-directory-xattrs","title":"file / directory xattrs","text":"<p>While they won't show up when using <code>getfattr</code> mergerfs offers a number of special xattrs to query information about the files served. To access the values you will need to issue a getxattr for one of the following:</p> <ul> <li>user.mergerfs.basepath: the base mount point for the file given the current getattr policy</li> <li>user.mergerfs.relpath: the relative path of the file from the perspective of the mount point</li> <li>user.mergerfs.fullpath: the full path of the original file given the getattr policy</li> <li>user.mergerfs.allpaths: a NUL ('\\0') separated list of full paths to all files found</li> </ul>"},{"location":"runtime_interfaces/#signals","title":"Signals","text":"<ul> <li>USR1: This will cause mergerfs to send invalidation notifications to   the kernel for all files. This will cause all unused files to be   released from memory.</li> <li>USR2: Trigger a general cleanup of currently unused memory. A more   thorough version of what happens every ~15 minutes.</li> </ul>"},{"location":"runtime_interfaces/#ioctl","title":"ioctl","text":"<p>Found in <code>fuse_ioctl.cpp</code>:</p> <pre><code>typedef char IOCTL_BUF[4096];\n#define IOCTL_APP_TYPE             0xDF\n#define IOCTL_FILE_INFO            _IOWR(IOCTL_APP_TYPE,0,IOCTL_BUF)\n#define IOCTL_GC                   _IO(IOCTL_APP_TYPE,1)\n#define IOCTL_GC1                  _IO(IOCTL_APP_TYPE,2)\n#define IOCTL_INVALIDATE_ALL_NODES _IO(IOCTL_APP_TYPE,3)\n</code></pre> <ul> <li>IOCTL_FILE_INFO: Same as the \"file / directory xattrs\" mentioned   above. Use a buffer size of 4096 bytes. Pass in a string of   \"basepath\", \"relpath\", \"fullpath\", or \"allpaths\". Receive details in   same buffer.</li> <li>IOCTL_GC: Triggers a thorough garbage collection of excess   memory. Same as SIGUSR2.</li> <li>IOCTL_GC1: Triggers a simple garbage collection of excess   memory. Same as what happens every 15 minutes normally.</li> <li>IOCTL_INVALIDATE_ALL_NODES: Same as SIGUSR1. Send invalidation   notifications to the kernel for all files causing unused files to be   released from memory.</li> </ul>"},{"location":"sponsorship_and_donations/","title":"Sponsorship and Donations","text":"<p>https://github.com/trapexit/support</p> <p>Development and support of a project like mergerfs requires a significant amount of time and effort. The software is released under the very liberal ISC license and is therefore free to use for personal or commercial uses.</p> <p>If you are a non-commercial user and find mergerfs and its support valuable and would like to support the project financially it would be very much appreciated.</p> <p>If you are using mergerfs commercially please consider sponsoring the project to ensure it continues to be maintained and receive updates. If custom features are needed feel free to contact me directly.</p>"},{"location":"support/","title":"Support","text":"<p>Filesystems are complex, as are the interactions software have with them, and therefore difficult to debug. When reporting on a suspected issue please include as much of the below information as possible otherwise it will be difficult or impossible to diagnose. Also please read the documentation as it provides details on many previously encountered questions/issues.</p> <p>Please make sure you are using the latest release or have tried it in comparison. Old versions, which are often included in distros like Debian and Ubuntu, are not ever going to be updated and the issue you are encountering may have been addressed already.</p> <p>For commercial support or feature requests please contact me directly.</p>"},{"location":"support/#information-to-include-in-bug-reports","title":"Information to include in bug reports","text":"<ul> <li>Information about the broader problem along with any attempted   solutions.</li> <li>Solution already ruled out and why.</li> <li>Version of mergerfs: <code>mergerfs --version</code></li> <li>mergerfs settings / arguments: from fstab, systemd unit, command   line, OMV plugin, etc.</li> <li>Version of the OS: <code>uname -a</code> and <code>lsb_release -a</code></li> <li>List of branches, their filesystem types, sizes (before and after issue): <code>df -h</code></li> <li>All information about the relevant paths and files: permissions, ownership, etc.</li> <li>All information about the client app making the requests: version, uid/gid</li> <li>Runtime environment:</li> <li>Is mergerfs running within a container?</li> <li>Are the client apps using mergerfs running in a container?</li> <li>A <code>strace</code> of the app having problems:</li> <li><code>strace -fvTtt -s 256 -o /tmp/app.strace.txt &lt;cmd&gt;</code></li> <li>A <code>strace</code> of mergerfs while the program is trying to do whatever it is failing to do:</li> <li><code>strace -fvTtt -s 256 -p &lt;mergerfsPID&gt; -o /tmp/mergerfs.strace.txt</code></li> <li>Precise directions on replicating the issue. Do not leave anything out.</li> <li>Try to recreate the problem in the simplest way using standard programs: <code>ln</code>, <code>mv</code>, <code>cp</code>, <code>ls</code>, <code>dd</code>, etc.</li> </ul>"},{"location":"support/#contact-issue-submission","title":"Contact / Issue submission","text":"<ul> <li>github.com: https://github.com/trapexit/mergerfs/issues</li> <li>discord: https://discord.gg/MpAr69V</li> <li>reddit: https://www.reddit.com/r/mergerfs</li> </ul>"},{"location":"terminology/","title":"Terminology","text":"<ul> <li><code>disk</code>, <code>drive</code>, <code>disk drive</code>: A physical data storage   device. Such as a hard   drive or solid-state drive. Usually requires the use of a filesystem   to be useful. mergerfs does not deal with disks.</li> <li><code>filesystem</code>: Lowlevel software which provides a way to organize data   and provide access to said data in a standard way. A filesystem is a   higher level abstraction that may or may not be stored on a   disk. mergerfs deals exclusively with filesystems.</li> <li><code>path</code>: A location within a filesystem. mergerfs can work with any   path within a filesystem and not simply the root.</li> <li><code>branch</code>: A base path used in a mergerfs pool. mergerfs can   accommodate multiple paths pointing to the same filesystem.</li> <li><code>pool</code>: The mergerfs mount. The union of the branches. The instance   of mergerfs. You can mount multiple mergerfs pools. Even with the   same branches.</li> <li><code>relative path</code>: The path in the pool relative to the branch and   mount. <code>foo/bar</code> is the relative path of mergerfs mount   <code>/mnt/mergerfs/foo/bar</code>.</li> <li><code>function</code>: A filesystem call such as <code>open</code>, <code>unlink</code>, <code>create</code>,   <code>getattr</code>, <code>rmdir</code>, etc. The requests your software make to the   filesystem.</li> <li><code>category</code>: A collection of functions based on basic behavior   (action, create, search).</li> <li><code>policy</code>: The algorithm used to select a file or files when   performing a function.</li> <li><code>path preservation</code>: Aspect of some policies which includes checking   the path for which a file would be created.</li> <li><code>out-of-band</code>:   out-of-band in our   context refers to interacting with the underlying filesystem   directly instead of going through mergerfs (or NFS or Samba).</li> </ul>"},{"location":"tips_notes/","title":"Tips and Notes","text":"<ul> <li>The documentation is explicit, literal, and reasonably thorough. If   a suspected feature is not mentioned it does not exist. Do not read   into the wording. What is described is how it functions. If you feel   like something is not explained sufficiently please file a   ticket.</li> <li>If a <code>libfuse</code> argument is not listed it probably shouldn't be used   and are unsupported.</li> <li>Ensure you're using the latest version. Especially before submitting   bug reports.</li> <li>Run mergerfs as <code>root</code>. mergerfs is designed and intended to be run   as <code>root</code> and may exhibit incorrect behavior if run otherwise.</li> <li>If you do not see some directories and files you expect, policies   seem to skip branches, you get strange permission errors, etc. be   sure the underlying filesystems' permissions are all the same. Use   <code>mergerfs.fsck</code> to audit the filesystem for out of sync permissions.</li> <li>If you still have permission issues be sure you are using POSIX ACL   compliant filesystems. mergerfs doesn't generally make exceptions   for FAT, NTFS, or other non-POSIX filesystem.</li> <li>Unless using Linux v6.6 or above do not use <code>cache.files=off</code> if   you expect applications (such as rtorrent) to use   mmap. Enabling <code>dropcacheonclose</code>   is recommended when <code>cache.files=auto-full</code>.</li> <li>Kodi, Plex,   Subsonic, etc. can use directory   mtime to more efficiently   determine whether to scan for new content rather than simply   performing a full scan. If using the default <code>getattr</code> policy of   <code>ff</code> it's possible those programs will miss an update on account of   it returning the first directory found's <code>stat</code> info and it is a   later directory on another mount which had the <code>mtime</code> recently   updated. To fix this you will want to set   <code>func.getattr=newest</code>. Remember though that this is just <code>stat</code>. If   the file is later <code>open</code>'ed or <code>unlink</code>'ed and the policy is   different for those then a completely different file or directory   could be acted on.</li> <li>Some policies mixed with some functions may result in strange   behaviors. Not that some of these behaviors and race conditions   couldn't happen outside mergerfs but that they are far more   likely to occur on account of the attempt to merge multiple sources   of data which could be out of sync due to the different policies.</li> <li>For consistency it's generally best to set <code>category</code> wide policies   rather than individual <code>func</code>'s. This will help limit the   confusion of tools such as   rsync. However, the flexibility   is there if needed.</li> </ul>"},{"location":"tooling/","title":"Tooling","text":""},{"location":"tooling/#preloadso","title":"preload.so","text":"<p>EXPERIMENTAL</p> <p>For some time there has been work to enable passthrough IO in FUSE. Passthrough IO would allow for near native performance with regards to reads and writes (at the expense of certain mergerfs features.) In Linux v6.9 that feature made its way into the kernel however in a somewhat limited form which is incompatible with aspects of how mergerfs currently functions. While work will continue to support passthrough IO in mergerfs this library was created to offer similar functionality in a more limited way.</p> <p><code>/usr/lib/mergerfs/preload.so</code></p> <p>This preloadable library overrides the creation and opening of files in order to simulate passthrough file IO. It catches the open/creat/fopen calls, has mergerfs do the call, queries mergerfs for the branch the file exists on, reopens the file on the underlying filesystem and returns that instead. Meaning that you will get native read/write performance because mergerfs is no longer part of the workflow. Keep in mind that this also means certain mergerfs features that work by interrupting the read/write workflow, such as <code>moveonenospc</code>, will no longer work.</p> <p>Also, understand that this will only work on dynamically linked software. Anything statically compiled will not work. Many GoLang and Rust apps are statically compiled.</p> <p>The library will not interfere with non-mergerfs filesystems. The library is written to always fallback to returning the mergerfs opened file on error.</p> <p>While the library was written to account for a number of edgecases there could be some yet accounted for so please report any oddities.</p> <p>Thank you to nohajc for prototyping the idea.</p>"},{"location":"tooling/#casual-usage","title":"casual usage","text":"<pre><code>LD_PRELOAD=/usr/lib/mergerfs/preload.so touch /mnt/mergerfs/filename\n</code></pre> <p>Or run <code>export LD_PRELOAD=/usr/lib/mergerfs/preload.so</code> in your shell or place it in your shell config file to have it be picked up by all software ran from your shell.</p>"},{"location":"tooling/#docker-and-podman-usage","title":"Docker and Podman usage","text":"<p>Assume <code>/mnt/fs0</code> and <code>/mnt/fs1</code> are pooled with mergerfs at <code>/media</code>.</p> <p>All mergerfs branch paths must be bind mounted into the container at the same path as found on the host so the preload library can see them.</p> <p>NOTE: Since a container can have its own OS setup there is no guarentee that <code>preload.so</code> from the host install will be compatible with the loader found in the container. If that is true it simply won't work and shouldn't cause any issues.</p> <pre><code>docker run \\\n  -e LD_PRELOAD=/usr/lib/mergerfs/preload.so \\\n  -v /usr/lib/mergerfs/preload.so:/usr/lib/mergerfs/preload.so:ro \\\n  -v /media:/media \\\n  -v /mnt:/mnt \\\n  ubuntu:latest \\\n  bash\n</code></pre> <p>or more explicitly</p> <pre><code>docker run \\\n  -e LD_PRELOAD=/usr/lib/mergerfs/preload.so \\\n  -v /usr/lib/mergerfs/preload.so:/usr/lib/mergerfs/preload.so:ro \\\n  -v /media:/media \\\n  -v /mnt/fs0:/mnt/fs0 \\\n  -v /mnt/fs1:/mnt/fs1 \\\n  ubuntu:latest \\\n  bash\n</code></pre>"},{"location":"tooling/#systemd-unit","title":"systemd unit","text":"<p>Use the <code>Environment</code> option to set the LD_PRELOAD variable.</p> <ul> <li>https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html#Command%20lines</li> <li>https://serverfault.com/questions/413397/how-to-set-environment-variable-in-systemd-service</li> </ul> <pre><code>[Service]\nEnvironment=LD_PRELOAD=/usr/lib/mergerfs/preload.so\n</code></pre>"},{"location":"tooling/#misc","title":"Misc","text":"<ul> <li>https://github.com/trapexit/mergerfs-tools</li> <li>mergerfs.ctl: A tool to make it easier to query and configure mergerfs at runtime</li> <li>mergerfs.fsck: Provides permissions and ownership auditing and the ability to fix them</li> <li>mergerfs.dedup: Will help identify and optionally remove duplicate files</li> <li>mergerfs.dup: Ensure there are at least N copies of a file across the pool</li> <li>mergerfs.balance: Rebalance files across filesystems by moving them from the most filled to the least filled</li> <li>mergerfs.consolidate: move files within a single mergerfs directory to the filesystem with most free space</li> <li>https://github.com/trapexit/scorch</li> <li>scorch: A tool to help discover silent corruption of files and keep track of files</li> <li>https://github.com/trapexit/bbf</li> <li>bbf (bad block finder): a tool to scan for and 'fix' hard drive bad blocks and find the files using those blocks</li> </ul>"},{"location":"usage_patterns/","title":"Usage Patterns","text":""},{"location":"usage_patterns/#tiered-cache","title":"tiered cache","text":"<p>Some storage technologies support what is called \"tiered\" caching. The placing of smaller, faster storage as a transparent cache to larger, slower storage. NVMe, SSD, or Optane in front of traditional HDDs for instance.</p> <p>mergerfs does not natively support any sort of tiered caching currently. The truth is for many users a cache would have little or no advantage over reading and writing directly. They would be bottlenecked by their network, internet connection, or limited size of the cache. However, there are a few situations where a tiered cache setup could help.</p> <ol> <li>Fast network, slow filesystems, many readers: You've a 10+Gbps     network with many readers and your regular filesystems can't keep     up.</li> <li>Fast network, slow filesystems, small'ish bursty writes: You have     a 10+Gbps network and wish to transfer amounts of data less than     your cache filesystem but wish to do so quickly and the time     between bursts is long enough to migrate data.</li> </ol> <p>With #1 it's arguable if you should be using mergerfs at all. A RAID level that can aggregate performance or using higher performance storage would probably be the better solution. If you're going to use mergerfs there are other tactics that may help: spreading the data across filesystems (see the mergerfs.dup tool) and setting <code>func.open=rand</code>, using <code>symlinkify</code>, or using dm-cache or a similar technology to add tiered cache to the underlying device itself.</p> <p>With #2 one could use a block cache solution as available via LVM and dm-cache but there is another solution which requires only mergerfs, a script to move files around, and a cron job to run said script.</p> <ul> <li>Create two mergerfs pools. One which includes just the slow   branches and one which has both the fast branches   (SSD,NVME,etc.) and slow branches. The base pool and the   cache pool.</li> <li>The cache pool should have the cache branches listed first in   the branch list in order to to make it easier to prioritize them.</li> <li>The best <code>create</code> policies to use for the cache pool would   probably be <code>ff</code>, <code>lus</code>, or <code>lfs</code>. The latter two under the   assumption that the cache filesystem(s) are far smaller than the   backing filesystems.</li> <li>You can also set the slow branches' mode to <code>NC</code> which would   give you the ability to use other <code>create</code> policies though that'd   mean if the cache filesystems fill you'd get \"out of space\"   errors. This however may be good as it would indicate the script   moving files around is not configured properly.</li> <li>Set your programs to use the cache pool.</li> <li>Configure the base pool with the <code>create</code> policy you would like   to lay out files as you like.</li> <li>Save one of the below scripts or create your own. The script's   responsibility is to move files from the cache branches (not   pool) to the base pool.</li> <li>Use <code>cron</code> (as root) to schedule the command at whatever frequency   is appropriate for your workflow.</li> </ul>"},{"location":"usage_patterns/#time-based-expiring","title":"time based expiring","text":"<p>Move files from cache filesystem to base pool which have an access time older than the supplied number of days. Replace <code>-atime</code> with <code>-amin</code> in the script if you want minutes rather than days.</p> <p>NOTE: The arguments to these scripts include the cache filesystem itself. Not the pool with the cache filesystem. You could have data loss if the source is the cache pool.</p> <p>mergerfs.time-based-mover</p> <p>Download: <pre><code>curl -o /usr/local/bin/mergerfs.time-based-mover https://raw.githubusercontent.com/trapexit/mergerfs/refs/heads/latest-release/tools/mergerfs.time-based-mover\n</code></pre></p> <p>crontab entry: <pre><code># m h  dom mon dow   command\n0 * * * * /usr/local/bin/mergerfs.time-based-mover /mnt/ssd/cache00 /mnt/base-pool 1\n</code></pre></p> <p>If you have more than one cache filesystem then simply add a cron entry for each.</p> <p>If you want to only move files from a subdirectory then use the subdirectories. <code>/mnt/ssd/cache00/foo</code> and <code>/mnt/base-pool/foo</code> respectively.</p>"},{"location":"usage_patterns/#percentage-full-expiring","title":"percentage full expiring","text":"<p>While the cache filesystem's percentage full is above the provided value move the oldest file from the cache filesystem to the base pool.</p> <p>NOTE: The arguments to these scripts include the cache filesystem itself. Not the pool with the cache filesystem. You could have data loss if the source is the cache pool.</p> <p>mergerfs.percent-full-mover</p> <p>Download: <pre><code>curl -o /usr/local/bin/mergerfs.percent-full-mover https://raw.githubusercontent.com/trapexit/mergerfs/refs/heads/latest-release/tools/mergerfs.percent-full-mover\n</code></pre></p> <p>crontab entry: <pre><code># m h  dom mon dow   command\n0 * * * * /usr/local/bin/mergerfs.percent-full-mover /mnt/ssd/cache00 /mnt/base-pool 80\n</code></pre></p> <p>If you have more than one cache filesystem then simply add a cron entry for each.</p> <p>If you want to only move files from a subdirectory then use the subdirectories. <code>/mnt/ssd/cache00/foo</code> and <code>/mnt/base-pool/foo</code> respectively.</p>"},{"location":"config/branches/","title":"branches","text":"<p>The <code>branches</code> argument is a colon (':') delimited list of paths to be pooled together. It does not matter if the paths are on the same or different filesystems nor does it matter the filesystem type (within reason). Used and available space metrics will not be duplicated for paths on the same filesystem and any features which aren't supported by the underlying filesystem (such as file attributes or extended attributes) will return the appropriate errors.</p> <p>Branches currently have two options which can be set. A mode which impacts whether or not the branch is included in a policy calculation and a individual minfreespace value. The values are set by prepending an <code>=</code> at the end of a branch designation and using commas as delimiters. Example: <code>/mnt/drive=RW,1234</code></p>"},{"location":"config/branches/#branch-mode","title":"branch mode","text":"<ul> <li>RW: (read/write) - Default behavior. Will be eligible in all policy   categories.</li> <li>RO: (read-only) - Will be excluded from <code>create</code> and <code>action</code>   policies. Same as a read-only mounted filesystem would be (though   faster to process).</li> <li>NC: (no-create) - Will be excluded from <code>create</code> policies. You can't   create on that branch but you can change or delete.</li> </ul>"},{"location":"config/branches/#minfreespace","title":"minfreespace","text":"<p>Same purpose and syntax as the global option but specific to the branch. Defaults to the global value.</p>"},{"location":"config/branches/#globbing","title":"globbing","text":"<p>To make it easier to include multiple branches mergerfs supports globbing. The globbing tokens MUST be escaped when using via the shell else the shell itself will apply the glob itself.</p> <pre><code># mergerfs /mnt/hdd\\*:/mnt/ssd /media\n</code></pre> <p>The above line will use all directories in /mnt prefixed with hdd as well as ssd.</p> <p>To have the pool mounted at boot or otherwise accessible from related tools use <code>/etc/fstab</code>.</p> <pre><code># &lt;file system&gt;        &lt;mount point&gt;  &lt;type&gt;    &lt;options&gt;             &lt;dump&gt;  &lt;pass&gt;\n/mnt/hdd*:/mnt/ssd    /media          mergerfs  minfreespace=16G      0       0\n</code></pre> <p>NOTE: The globbing is done at mount or when updated using the runtime API. If a new directory is added matching the glob after the fact it will not be automatically included.</p> <p>A convenient way to configure branches is to use symlinks.</p>"},{"location":"config/branches/#branch-setup","title":"branch setup","text":"<p>mergerfs does not require any special setup of branch paths in order to be used however here are some suggestions.</p>"},{"location":"config/branches/#layout","title":"layout","text":"<p>When you have a large collection of storage devices, types of storage, and types of interconnects it can be useful to have a verbose naming convention. My preference is to create a directory within <code>/mnt/</code> for each major type of storage device and/or interconnect. <code>hdd</code> for traditional hard drives; <code>ssd</code> for slower SATA based SSDs; <code>nvme</code> for M.2 or U.2 NVME SSDs; <code>remote</code> for NFS, SMB, sshfs, etc.</p> <p>The mount points within those directories are named after the size of the storage and its serial number in the case of physical storage and the hostname and remote filesystem for remote.</p> <pre><code>$ ls -lh /mnt/\ntotal 16K\ndrwxr-xr-x 8 root root 4.0K Aug 18  2024 hdd\ndrwxr-xr-x 6 root root 4.0K Oct  8  2024 nvme\ndrwxr-xr-x 3 root root 4.0K Aug 24  2024 remote\ndrwxr-xr-x 3 root root 4.0K Jul 14  2024 ssd\n\n$ ls -lh /mnt/hdd/\ntotal 8K\nd--------- 2 root root 4.0K Apr 14 15:58 10T-01234567\nd--------- 2 root root 4.0K Apr 12 20:51 20T-12345678\n\n$ ls -lh /mnt/nvme/\ntotal 8K\nd--------- 2 root root 4.0K Apr 14 16:00 1T-ABCDEFGH\nd--------- 2 root root 4.0K Apr 14 23:24 1T-BCDEFGHI\n\n$ ls -lh /mnt/remote/\ntotal 8K\nd--------- 2 root root 4.0K Apr 12 20:23 foo-sshfs\nd--------- 2 root root 4.0K Apr 12 20:24 bar-nfs\n\n# You can find the serial number of a drive using lsblk\n$ lsblk -d -o NAME,PATH,SIZE,SERIAL\nNAME    PATH           SIZE SERIAL\nsda     /dev/sda       9.1T 01234567\nsdb     /dev/sdb      18.2T 12345678\nnvme0n1 /dev/nvme0n1 953.9G ABCDEFGH\nnvme1n1 /dev/nvme1n1 953.9G BCDEFGHI\n</code></pre>"},{"location":"config/branches/#permissions-and-mode","title":"permissions and mode","text":""},{"location":"config/branches/#mount-points","title":"mount points","text":"<p>To ensure the directory is only used as a point to mount another filesystem it is good to lock it down as much as possible. Be sure to do this before mounting a filesystem to it.</p> <pre><code>$ sudo chown root:root /mnt/hdd/10T-XYZ\n$ sudo chmod 0000 /mnt/hdd/10T-XYZ\n$ sudo setfattr -n user.mergerfs.branch_mounts_here\n$ sudo chattr +i /mnt/hdd/10T-XYZ\n</code></pre> <p>The extended attribute <code>user.mergerfs.branch_mounts_here</code> is used by the branches-mount-timeout option to recognize whether or not a mergerfs branch path points to the intended filesystem.</p> <p>The <code>chattr</code> is likely to only work on EXT{2,3,4} filesystems but will restrict even <code>root</code> from modifying the directory or its content.</p>"},{"location":"config/branches/#mounted-filesystems","title":"mounted filesystems","text":"<p>For those new to Linux, intending to be the primary individual logged into the system, or simply want to simplify permissions it is recommended to set the root of mounted filesystems like <code>/tmp/</code> is set to. Owned by <code>root</code>, <code>ugo+rwx</code> and sticky bit set.</p> <p>This must be done after mounting the filesystem to the target mount point.</p> <pre><code>$ sudo chown root:root /mnt/hdd/10T-SERIALNUM\n$ sudo chmod 1777 /mnt/hdd/10T-SERIALNUM\n$ sudo setfattr -n user.mergerfs.branch /mnt/hdd/10T-SERIALNUM\n</code></pre>"},{"location":"config/branches/#formatting","title":"formatting","text":"<p>While even less relevant to mergerfs than the details above the topic does com up regularly with mergerfs users. When it comes to partitioning and formatting it is suggested to keep things simple. Most users of mergerfs will be using the whole drive capacity and as such have a singular partition and filesystem on that partition. Something many people don't realize is that the partition is not necessary and actually can become problematic.</p> <p>Rather than creating paritions just format the block device. Let's use <code>/dev/sda</code> as an example.</p> <pre><code>$ lsblk -d -o NAME,PATH,SERIAL /dev/sda\nNAME    PATH         SERIAL\nsda     /dev/sda     01234567\n\n$ sudo mkfs.ext4 -m0 -L 01234567 /dev/sda\nmke2fs 1.47.0 (5-Feb-2023)\nDiscarding device blocks: done\nCreating filesystem with 262144 4k blocks and 65536 inodes\nFilesystem UUID: ede8bf96-9aff-464e-a4fb-a4ab8a197cd7\nSuperblock backups stored on blocks:\n        32768, 98304, 163840, 229376\n\nAllocating group tables: done\nWriting inode tables: done\nCreating journal (8192 blocks): done\nWriting superblocks and filesystem accounting information: done\n</code></pre> <p>You can then use the serial number as the identifier in <code>fstab</code>.</p> <pre><code># &lt;file system&gt;  &lt;mount point&gt;           &lt;type&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;\nLABEL=01234567   /mnt/hdd/10TB-01234567  auto    nofail     0       2\n</code></pre> <p>Benefits of doing it this way?</p> <ul> <li>One less thing (partitions) to configure and worry about.</li> <li>Guarantees alignment of blocks</li> <li>Makes it easier to use the drive with different enclosures. Some   SATA to USB adapters use 4K blocks while the drive itself is using   512b. If you create partitions with one block size and move the   drive to a controller that uses the other the offset on the device   where the filesystem starts will be misinterpreted. It is possible   to manually fix this but it isn't well documented and avoidable.</li> </ul>"},{"location":"config/branches_mount_timeout/","title":"branches-mount-timeout","text":"<p>Default: <code>0</code></p> <p>mergerfs is compatible with any path, whether it be a mount point or a directory on your root filesystem. It doesn\u2019t require branch paths to be mounted or to match a specific filesystem at startup, and it operates effectively without needing details about the intended filesystem. This flexibility eliminates the need to manage mount ordering, which is particularly advantageous on modern systems where filesystems are mounted asynchronously, resulting in unpredictable mount sequences. While systemd offers a way to enforce mount dependencies using the x-systemd.requires=PATH option in /etc/fstab, applying this to every branch path is both cumbersome and susceptible to errors.</p> <p><code>branches-mount-timeout</code> will cause mergerfs to wait for all branches to become \"mounted.\" The logic to determine \"mounted\" is as follows.</p> <ol> <li>It is mounted if the branch directory has the extended attribute    <code>user.mergerfs.branch</code></li> <li>It is mounted if the branch directory contains a file named    <code>.mergerfs.branch</code></li> <li>It is not mounted if the branch directory has the extended    attribute <code>user.mergerfs.branch_mounts_here</code></li> <li>It is not mounted if the branch directory contains    a file named <code>.mergerfs.branch_mounts_here</code></li> <li>It is mounted if the <code>st_dev</code> value of the mergerfs mountpoint is    different from the branch path.</li> </ol> <p>NOTE: If on a <code>systemd</code> based system and using <code>fstab</code> it is a good idea to set the mount option x-systemd.mount-timeout to some value longer than <code>branches-mount-timeout</code>.</p>"},{"location":"config/branches_mount_timeout/#branches-mount-timeout-fail","title":"branches-mount-timeout-fail","text":"<p>Default: <code>false</code></p> <p>When set to <code>true</code> mergerfs will fail entirely after <code>branches-mount-timeout</code> expires without all branches being mounted. If set to <code>false</code> it will simply ignore the mount status of the branches and continue on. The details will be logged.</p>"},{"location":"config/cache/","title":"caching","text":""},{"location":"config/cache/#cachefiles","title":"cache.files","text":"<p>Controls how page caching works for mergerfs itself. Not the underlying filesystems.</p> <ul> <li><code>cache.files=off</code>: Disables page caching for mergerfs.</li> <li><code>cache.files=partial</code>: Enables page caching. Files are cached   while open.</li> <li><code>cache.files=full</code>: Enables page caching. Files are cached across   opens.</li> <li><code>cache.files=auto-full</code>: Enables page caching. Files are cached   across opens if mtime and size are unchanged since previous open.</li> <li><code>cache.files=per-process</code>: Enable page caching (equivalent to   <code>cache.files=partial</code>) only for processes whose 'comm' name matches   one of the values defined in cache.files.process-names. If the name   does not match the file open is equivalent to <code>cache.files=off</code>.</li> </ul> <p>Generally, enabling the page cache actually harms performance<sup>1</sup>. In part because it can lead to buffer bloat due to the kernel caching both the underlying filesystem's file content as well as the file through mergerfs. However, if you want to confirm performance differences it is recommended that you perform some benchmark to confirm which option works best for your setup.</p> <p>Why then would you want to enable page caching if it consumes ~2x the RAM as normal and is on average slower? Because it is the only way to support mmap. <code>mmap</code> is a way for programs to treat a file as if it is a contiguous RAM buffer which is regularly used by a number of programs such as those that leverage sqlite3. Despite <code>mmap</code> not being supported by all filesystems it is unfortunately common for software to not have an option to use regular file IO instead of <code>mmap</code>.</p> <p>The good thing is that in Linux v6.6<sup>2</sup> and above FUSE can now transparently enable page caching when mmap is requested. This means it should be safe to set <code>cache.files=off</code>. However, on Linux v6.5 and below you will need to configure <code>cache.files</code> as you need.</p>"},{"location":"config/cache/#cacheentry","title":"cache.entry","text":"<ul> <li><code>cache.entry=UINT</code>: Sets the number of seconds to cache   entry queries. Defaults to <code>1</code>.</li> </ul> <p>The kernel must ask mergerfs about the existence of files. The entry cache caches that those details which limits the number of requests sent to mergerfs.</p> <p>The risk of setting this value, as with most any cache, is related to out-of-band changes. If the filesystems are changed outside mergerfs there is a risk of files which have been removed continuing to show as available. It will fail gracefully if a phantom file is actioned on in some way so there is little risk in setting the value much higher. Especially if there are no out-of-band changes.</p>"},{"location":"config/cache/#cachenegative_entry","title":"cache.negative_entry","text":"<ul> <li><code>cache.negative_entry=UINT</code>: Sets the number of seconds to cache   negative entry queries. Defaults to <code>1</code>.</li> </ul> <p>This is a cache for negative entry query responses. Such as when a file which does not exist is referenced.</p> <p>The risk of setting this value, as with most any cache, is related to out-of-band changes. If the filesystems are changed outside mergerfs there is a risk of files which have been added outside mergerfs not appearing correctly till the cache entry times out if there had been a request for the same name within mergerfs which didn't exist. This is mostly an inconvenience.</p>"},{"location":"config/cache/#cacheattr","title":"cache.attr","text":"<ul> <li><code>cache.attr=UINT</code>: Sets the number of seconds to cache file   attributes. Defaults to <code>1</code>.</li> </ul> <p>This is a cache for file attributes and metadata such as that which is collected by the stat system call which is used when you run commands such as <code>find</code> or <code>ls -lh</code>. </p> <p>As with other caches the risk of enabling the attribute cache is if changes are made to the file out-of-band there could be inconsistencies between the actual file and the cached details which could result in different issues depending on how the data is used. If the simultaneous writing of a file from inside and outside is unlikely then you should be safe. That said any simultaneous, uncoordinated manipulation of a file can lead to unexpected results.</p>"},{"location":"config/cache/#cachestatfs","title":"cache.statfs","text":"<ul> <li><code>cache.statfs=UINT</code>: Sets the number of seconds to cache <code>statfs</code>   calls used by policies. Defaults to <code>0</code>.</li> </ul> <p>A number of policies require looking up the available space of the branches being considered. This is accomplished by calling statfs. This call however is a bit expensive so this cache reduces the overhead by limiting how often the calls are actually made.</p> <p>This will mean that if the available space of branches changed somewhat rapidly there is a risk of <code>create</code> or <code>mkdir</code> calls made within the timeout period ending up on the same branch. This however should even itself out over time.</p>"},{"location":"config/cache/#cachesymlinks","title":"cache.symlinks","text":"<ul> <li><code>cache.symlinks=BOOL</code>: Enable kernel caching of symlink   values. Defaults to <code>false</code>.</li> </ul> <p>As of Linux v4.20 there is an ability to cache the value of symlinks so that the kernel does not need to make a request to mergerfs every single time a readlink request is made. While not a common usage pattern, if software very regularly queries symlink values, the use of this cache could significantly improve performance.</p> <p>mergerfs will not error if the kernel used does not support symlink caching.</p> <p>As with other caches the main risk in enabling it is if you are manipulating symlinks from both within and without the mergerfs mount. Should the value be changed outside of mergerfs then it will not be reflected in the mergerfs mount till the cached value is invalidated.</p>"},{"location":"config/cache/#cachereaddir","title":"cache.readdir","text":"<ul> <li><code>cache.readdir=BOOL</code>: Enable kernel caching of readdir   results. Defaults to <code>false</code>.</li> </ul> <p>As of Linux v4.20 it supports readdir caching. This can have a significant impact on directory traversal. Especially when combined with entry (<code>cache.entry</code>) and attribute (<code>cache.attr</code>) caching. If the kernel doesn't support readdir caching setting the option to true has no effect. This option is configurable at runtime via xattr user.mergerfs.cache.readdir.</p>"},{"location":"config/cache/#cachewriteback","title":"cache.writeback","text":"<ul> <li><code>cache.writeback=BOOL</code>: Enable writeback cache. Defaults to <code>false</code>.</li> </ul> <p>When <code>cache.files</code> is enabled the default is for it to perform writethrough caching. This behavior won't help improve performance as each write still goes one for one through the filesystem. By enabling the FUSE writeback cache small writes may be aggregated by the kernel and then sent to mergerfs as one larger request. This can greatly improve the throughput for apps which write to files inefficiently. The amount the kernel can aggregate is limited by the size of a FUSE message. Read the fuse_msg_size section for more details.</p> <p>There is a side effect as a result of enabling writeback caching. Underlying files won't ever be opened with O_APPEND or O_WRONLY. The former because the kernel then manages append mode and the latter because the kernel may request file data from mergerfs to populate the write cache. The O_APPEND change means that if a file is changed outside of mergerfs it could lead to corruption as the kernel won't know the end of the file has changed. That said any time you use caching you should keep from writing to the same file outside of mergerfs at the same time.</p> <p>Note that if an application is properly sizing writes then writeback caching will have little or no effect. It will only help with writes of sizes below the FUSE message size (128K on older kernels, 1M on newer). Even then its effectiveness might not be great. Given the side effects of enabling this feature it is recommended that its benefits be proved out with benchmarks.</p> <ol> <li> <p>This is not unique to mergerfs and affects all FUSE filesystems. It is something that the FUSE community hopes to investigate at some point but as of early 2025 there are a number of major reworking going on with FUSE which needs to be finished first.\u00a0\u21a9</p> </li> <li> <p>https://kernelnewbies.org/Linux_6.6#FUSE \u21a9</p> </li> </ol>"},{"location":"config/deprecated_options/","title":"Deprecated Options","text":"<p>These are old, deprecated options which may no longer have any function or have been replaced. They should not be used.</p> <ul> <li>direct_io: Bypass page cache. Use <code>cache.files=off</code>   instead.</li> <li>kernel_cache: Do not invalidate data cache on file open. Use   <code>cache.files=full</code> instead.</li> <li>auto_cache: Invalidate data cache if file mtime or   size change. Use <code>cache.files=auto-full</code> instead. (default: false)</li> <li>async_read: Perform reads asynchronously. Use   <code>async_read=true</code> instead.</li> <li>sync_read: Perform reads synchronously. Use   <code>async_read=false</code> instead.</li> <li>splice_read: Does nothing.</li> <li>splice_write: Does nothing.</li> <li>splice_move: Does nothing.</li> <li>allow_other: mergerfs v2.35.0 and above sets this FUSE option   automatically if running as root.</li> <li>use_ino: Effectively replaced with <code>inodecalc</code>.</li> </ul>"},{"location":"config/export-support/","title":"export-support","text":"<ul> <li><code>export-support=true|false</code></li> <li>Default: <code>true</code></li> </ul> <p>In theory, this flag should not be exposed to the end user. It is a low-level FUSE flag which indicates whether or not the kernel can send certain kinds of messages to it for the purposes of using it with NFS. mergerfs does support these messages but due to bugs and quirks found in the kernel and mergerfs this option is provided just in case it is needed for debugging.</p> <p>Given that this flag is set when the FUSE connection is first initiated it is not possible to change during run time.</p>"},{"location":"config/flush-on-close/","title":"flush-on-close","text":"<p>By default, FUSE would issue a flush before the release of a file descriptor. This was considered a bit aggressive and a feature added to give the FUSE server the ability to choose when that happens.</p> <ul> <li><code>flush-on-close=always</code></li> <li><code>flush-on-close=never</code></li> <li><code>flush-on-close=opened-for-write</code></li> <li>Defaults to <code>opened-for-write</code>.</li> </ul> <p>For now it defaults to <code>opened-for-write</code> which is less aggressive than the behavior before this feature was added. It should not be a problem because the flush is really only relevant when a file is written to. Given flush is irrelevant for many filesystems in the future a branch specific flag may be added so only files opened on a specific branch would be flushed on close.</p>"},{"location":"config/flush-on-close/#references","title":"References","text":"<ul> <li>https://lkml.kernel.org/linux-fsdevel/20211024132607.1636952-1-amir73il@gmail.com/T/</li> </ul>"},{"location":"config/follow-symlinks/","title":"follow-symlinks","text":"<p>This feature, when enabled, will cause symlinks to be interpreted by mergerfs as their target.</p> <p>When there is a getattr/stat request for a file mergerfs will check if the file is a symlink and depending on the <code>follow-symlinks</code> setting will replace the information about the symlink with that of that which it points to.</p> <p>When unlink'ing or rmdir'ing the followed symlink it will remove the symlink itself and not that which it points to.</p> <ul> <li><code>follow-symlinks=never</code>: Behave as normal. Symlinks are treated as such.</li> <li><code>follow-symlinks=directory</code>: Resolve symlinks only which point to directories.</li> <li><code>follow-symlinks=regular</code>: Resolve symlinks only which point to regular files.</li> <li><code>follow-symlinks=all</code>: Resolve all symlinks to that which they point   to. Symlinks which do not point to anything are left as is.</li> <li>Defaults to <code>never</code>.</li> </ul> <p>WARNING: This feature should be considered experimental. There might be edge cases yet found. If you find any odd behaviors please file a ticket on github.</p>"},{"location":"config/func_readdir/","title":"func.readdir","text":"<p>Defaults to <code>seq</code></p> <p>Examples: <code>func.readdir=seq</code>, <code>func.readdir=cor:4</code></p> <p><code>readdir</code> has policies to control how it reads directory content.</p> Policy Description seq \"sequential\" : Iterate sequentially over branches in the order defined in <code>branches</code>. This is the default and traditional behavior found prior to the readdir policy introduction. This will be increasingly slower as more branches are added to the pool. Especially if needing to wait for drives to spin up or network filesystems to respond. cosr:N:M \"concurrent open, sequential read\" : Concurrently open branch directories using a thread pool and process them in the order defined in <code>branches</code>. This keeps memory and CPU usage low while also reducing the time spent waiting on branches to respond. <code>N</code> is the number of threads. If negative it will be the core count divided by <code>abs(N)</code>. <code>M</code> is the queue depth. If either value is <code>0</code> it will be decided based on system configuration. cosr:N cosr:N:M with M = 0 cosr cosr:N:M with N = 0 and M = 0 cor:N:M \"concurrent open and read\" : Concurrently open branch directories and immediately start reading their contents using a thread pool. This will result in slightly higher memory and CPU usage but reduced latency. Particularly when using higher latency / slower speed network filesystem branches. Unlike <code>seq</code> and <code>cosr</code> the order of files could change due the async nature of the thread pool. This should not be a problem since the order of files listed in not guaranteed.  <code>N</code> is the number of threads. If negative it will be the core count divided by <code>abs(N)</code>. <code>M</code> is the queue depth. If either value is <code>0</code> it will be decided based on system configuration. cor:N cosr:N:M with M = 0 cor cosr:N:M with N = 0 and M = 0 <p>Keep in mind that <code>readdir</code> mostly just provides a list of file names in a directory and possibly some basic metadata about said files. To know details about the files, as one would see from commands like <code>find</code> or <code>ls</code>, it is required to call <code>stat</code> on the file which is controlled by <code>fuse.getattr</code>.</p>"},{"location":"config/functions_categories_policies/","title":"functions, categories and policies","text":"<p>The POSIX filesystem API is made up of a number of functions. <code>creat</code>, <code>stat</code>, <code>chown</code>, etc. For ease of configuration in mergerfs, most of the core functions are grouped into 3 categories: <code>action</code>, <code>create</code>, and <code>search</code>. These functions and categories can be assigned a policy which dictates which branch is chosen when performing that function.</p> <p>Some functions, listed in the category <code>N/A</code> below, can not be assigned the normal policies because they are directly related to a file which has already been opened.</p>"},{"location":"config/functions_categories_policies/#functions-and-their-category-classifications","title":"Functions and their Category classifications","text":"Category Functions action chmod, chown, link, removexattr, rename, rmdir, setxattr, truncate, unlink, utimens create create, mkdir, mknod, symlink search access, getattr, getxattr, ioctl (directories), listxattr, open, readlink N/A fchmod, fchown, futimens, ftruncate, fallocate, fgetattr, fsync, ioctl (files), read, readdir, release, statfs, write, copy_file_range <p>In cases where something may be searched for (such as a path to clone) <code>getattr</code> will usually be used.</p>"},{"location":"config/functions_categories_policies/#policies","title":"Policies","text":"<p>See below for available policies and their descriptions.</p> <p>A policy is an algorithm designed to select one or more branches for a function to operate on.</p> <p>Policies do not actually manage the filesystem or layout. They are strictly responsible for deciding which files or branches will be worked on in relation to the function being performed. Once the branch is chosen other parts of the system does what is necessary to accomplish the function. Such as the cloning of directories between branches.</p> <p>When using policies which are based on a branch's available space the branch base path provided is used. Not the full path to the file or directory in question. Meaning that mounts within the branch will not be considered in the space calculations.</p> <p>NOTE: While any policy can be assigned to a function or category, some may not be very useful in practice. For instance: <code>rand</code> (random) may be useful for file creation but could lead to very odd behavior if used for <code>chmod</code> if there were more than one copy of the file. Unless users find this flexibility useful it will likely be removed in the future.</p>"},{"location":"config/functions_categories_policies/#filtering","title":"Filtering","text":"<p>Most policies search branches and create a list of files / paths for functions to work on. The policy is responsible for filtering and sorting the branches. Filters include minfreespace, whether or not a branch is mounted read-only, and the branch mode (RO,NC,RW). These filters are applied across most policies.</p> <ul> <li>No <code>search</code> function policies filter.</li> <li>All <code>action</code> function policies filter out branches which are   mounted read-only or mode is RO (read-only).</li> <li>All <code>create</code> function policies filter out branches which are   mounted read-only, mode RO (read-only) or NC (no   create), or has available space less than   minfreespace.</li> </ul> <p>Policies may have their own additional filtering such as those that require existing paths to be present.</p> <p>If all branches are filtered an error will be returned. Typically <code>EROFS</code> (read-only filesystem) or <code>ENOSPC</code> (no space left on device) depending on the most recent reason for filtering a branch.</p> <p>If <code>create</code>, <code>mkdir</code>, <code>mknod</code>, or <code>symlink</code> fail with <code>EROFS</code> or other fundamental errors then mergerfs will mark any branch found to be read-only as such (IE will set the mode <code>RO</code>) and will rerun the policy and try again. This is mostly for <code>ext4</code> filesystems that can suddenly become read-only when it encounters an error.</p>"},{"location":"config/functions_categories_policies/#path-preservation","title":"Path Preservation","text":"<p>Policies, as described below, are of two basic classifications. <code>path preserving</code> and <code>non-path preserving</code>.</p> <p>All policies which start with <code>ep</code> (<code>epff</code>, <code>eplfs</code>, <code>eplus</code>, <code>epmfs</code>, <code>eprand</code>) are <code>path preserving</code>. <code>ep</code> stands for <code>existing path</code>.</p> <p>A path preserving policy will only consider branches where the relative path being accessed already exists.</p> <p>With the <code>msp</code> or <code>most shared path</code> policies they are defined as <code>path preserving</code> for the purpose of controlling <code>link</code> and <code>rename</code>'s behaviors since <code>ignorepponrename</code> is available to disable that behavior.</p>"},{"location":"config/functions_categories_policies/#policy-descriptions","title":"Policy descriptions","text":"<p>A policy's behavior differs, as mentioned above, based on the function it is used with. Sometimes it really might not make sense to even offer certain policies because they are literally the same as others but it makes things a bit more uniform.</p> Policy Description pfrd (percentage free random distribution) Selects a branch randomly, with the probability of selection proportional to its available space relative to the total available space across all branches. For instance, if Branch A has 100 GB free and Branch B has 50 GB free, Branch A is twice as likely to be chosen. rand (random) Calls all and then randomizes. Returns 1 branch. mfs (most free space) Pick the branch with the most available free space. ff (first found) Given the order of the branches, as defined at mount time or configured at runtime, act on the first one found. lfs (least free space) Pick the branch with the least available free space. lus (least used space) Pick the branch with the least used space. all Search: For mkdir, mknod, and symlink it will apply to all branches. create works like ff. msppfrd (most shared path, percentage free random distribution) Like eppfrd but if it fails to find a branch it will try again with the parent directory. Continues this pattern till finding one. mspmfs (most shared path, most free space) Like epmfs but if it fails to find a branch it will try again with the parent directory. Continues this pattern till finding one. msplfs (most shared path, least free space) Like eplfs but if it fails to find a branch it will try again with the parent directory. Continues this pattern till finding one. msplus (most shared path, least used space) Like eplus but if it fails to find a branch it will try again with the parent directory. Continues this pattern till finding one. eppfrd (existing path, percentage free random distribution) Like pfrd but limited to existing paths. epmfs (existing path, most free space) Of all the branches on which the relative path exists choose the branch with the most free space. eprand (existing path, random) Calls epall and then randomizes. Returns 1. epff (existing path, first found) Given the order of the branches, as defined at mount time or configured at runtime, act on the first one found where the relative path exists. eplfs (existing path, least free space) Of all the branches on which the relative path exists choose the branch with the least free space. eplus (existing path, least used space) Of all the branches on which the relative path exists choose the branch with the least used space. epall (existing path, all) For mkdir, mknod, and symlink it will apply to all found. create works like epff (but more expensive because it doesn't stop after finding a valid branch). newest Pick the file / directory with the largest mtime. <p>NOTE: If you are using an underlying filesystem that reserves blocks such as ext2, ext3, or ext4 be aware that mergerfs respects the reservation by using <code>f_bavail</code> (number of free blocks for unprivileged users) rather than <code>f_bfree</code> (number of free blocks) in policy calculations. df does NOT use <code>f_bavail</code>, it uses <code>f_bfree</code>, so direct comparisons between df output and mergerfs' policies is not appropriate.</p>"},{"location":"config/functions_categories_policies/#defaults","title":"Defaults","text":"Category Policy action epall create pfrd search ff"},{"location":"config/fuse_msg_size/","title":"fuse_msg_size","text":"<ul> <li><code>fuse_msg_size=UINT|SIZE</code></li> <li>Defaults to <code>1M</code></li> <li>Performance improvements often peak at about <code>4M</code></li> </ul> <p>FUSE applications communicate with the kernel over a special character device: <code>/dev/fuse</code>. A large portion of the overhead associated with FUSE is the cost of going back and forth between user space and kernel space over that device. Generally speaking, the fewer trips needed the better the performance will be. Reducing the number of trips can be done a number of ways. Kernel level caching and increasing message sizes being two significant ones. When it comes to reads and writes if the message size is doubled the number of trips are approximately halved.</p> <p>In Linux v4.20 a new feature was added allowing the negotiation of the max message size. Since the size is in multiples of pages the feature is called <code>max_pages</code>. In versions of Linux prior to v6.13 there is a maximum <code>max_pages</code> value of 256 (1MiB) and minimum of 1 (4KiB). In Linux v6.13 and above the max value supported by the kernel can range from 1 (4KiB) to 65535 (~256MiB) (assuming a page size of 4KiB.) The default used by Linux &gt;= 4.20, and hard coded value used before 4.20, is 32 (128KiB). In mergerfs it is referred to as <code>fuse_msg_size</code> to make it clear what it impacts and provide some abstraction.</p> <p>If the <code>fuse_msg_size</code> value provided is more than the system wide maximum mergerfs will attempt to increase the system wide value to keep the user from needing to set the value using <code>sysctl</code>, <code>/etc/sysctl.conf</code>, or <code>/proc/sys/fs/fuse/max_pages_limit</code>.</p> <p>The main downside to increasing the value is that memory usage will increase approximately relative to the number of processing threads configured. Keep this in mind for systems with lower amounts of memory like most SBCs. Performance improvements seem to peak around 4MiB.</p> <p>On kernels before v4.20 the option has no effect. On kernels between v4.20 and v6.13 the max value is 256. On kernels &gt;= v6.13 the maximum value is 65535.</p> <p>Since page size can differ between systems mergerfs can take a value in bytes and will convert it to the proper number of pages (rounded up).</p> <p>NOTE: If you intend to enable <code>cache.files</code> you should also set readahead to match <code>fuse_msg_size</code>.</p>"},{"location":"config/inodecalc/","title":"inodecalc","text":"<p>Inodes (<code>st_ino</code>) are unique identifiers for files within a filesystem. Each mounted filesystem also has a (typically) unique device ID (<code>st_dev</code>) as well and together they can uniquely identify a file on the whole of the system. Entries on the same device with the same inode are (generally) in fact references to the same underlying file. It is a many to one relationship between names and an inode. Directories, however, do not have multiple links on most systems due to the complexity that would add.</p> <p>FUSE allows the server (in this case <code>mergerfs</code>) to set inode values but not device IDs. Creating an inode value is somewhat complex in mergerfs' case as files aren't really in its control. If a policy changes what directory or file is to be selected or changes are made to branches out of band it becomes unclear what value should be used. Most software does not to care what the values are but those that do often break if a value changes unexpectedly. For instance: the tool <code>find</code> will abort a directory walk if it sees a directory inode change. NFS can return stale handle errors if the inode changes out-of-band. File dedup tools will usually leverage device ids and inodes as a shortcut in searching for duplicate files and would resort to full file comparisons should it find different inode values.</p> <p>mergerfs offers multiple ways to calculate the inode in hopes of covering different usecases.</p> <ul> <li><code>passthrough</code>: Passes through the underlying inode value. Mostly   intended for testing as using this does not address any of the   problems mentioned above and could confuse file deduplication   software as inodes from different filesystems can be the same.</li> <li><code>path-hash</code>: Hashes the relative path of the entry in question. The   underlying file's values are completely ignored. This means the   inode value will always be the same for that file path. This is   useful when using NFS and you make changes out of band such as copy   data between branches. This also means that entries that do point to   the same file will not be recognizable via inodes. That does not   mean hard links don't work. They will.</li> <li><code>path-hash32</code>: 32bit version of path-hash.</li> <li><code>devino-hash</code>: Hashes the branch path and inode of the underlying   entry. This won't prevent issues with NFS should the policy pick a   different file or files move out of band but will present the same   inode for underlying files that share the same inode. Previous   releases of mergerfs used the device ID but that changes on   reboot. The downside to using the branch path is inodes for files on   the same underlying filesystem will be different.</li> <li><code>devino-hash32</code>: 32bit version of devino-hash.</li> <li><code>hybrid-hash</code>: Performs path-hash on directories and devino-hash on   other file types. Since directories can't have hard links the static   value won't make a difference and the files will get values useful   for finding duplicates. Probably the best to use if not using   NFS. As such it is the default.</li> <li><code>hybrid-hash32</code>: 32bit version of hybrid-hash.</li> </ul> <p>32bit versions are provided as there is some software which does not handle 64bit inodes well.</p> <p>While there is a risk of hash collision in tests of a couple of million entries there were zero collisions. Unlike a typical filesystem FUSE filesystems can reuse inodes and not refer to the same entry. The internal identifier used to reference a file in FUSE is different from the inode value presented. The former is the nodeid and is actually a tuple of 2 64bit values: nodeid and generation. This tuple is not client facing. The inode that is presented to the client is passed through the kernel uninterpreted.</p> <p>From FUSE docs for <code>use_ino</code>:</p> <p>Honor the st_ino field in the functions getattr() and fill_dir(). This value is used to fill in the st_ino field in the stat(2), lstat(2), fstat(2) functions and the d_ino field in the readdir(2) function. The filesystem does not have to guarantee uniqueness, however some applications rely on this value being unique for the whole filesystem. Note that this does not affect the inode that libfuse and the kernel use internally (also called the \"nodeid\").</p> <p>NOTE: As of version 2.35.0 the use_ino option has been removed. mergerfs should always be managing inode values.</p>"},{"location":"config/kernel-permissions-check/","title":"kernel-permissions-check","text":"<ul> <li><code>kernel-permissions-check=true|false</code></li> <li>Default: <code>true</code></li> </ul> <p>FUSE has a feature which mergerfs leverages which allows the kernel to do file permission checking rather than leaving it to the FUSE server (in this case mergerfs.) This improves performance. However, it also limits flexibility.</p> <p>mergerfs should work fine regardless of this setting but there might be some currently unknown edge cases where disabling the feature might help. Like export-support this is mostly for debugging.</p> <p>This option is a kernel mount option so unable to be changed at runtime.</p>"},{"location":"config/link-exdev/","title":"link-exdev","text":"<p>If using path preservation and a <code>link</code> fails with <code>EXDEV</code> make a call to <code>symlink</code> where the target is the <code>oldlink</code> and the <code>linkpath</code> is the newpath. The target value is determined by the value of <code>link-exdev</code>.</p> <ul> <li><code>link-exdev=passthrough</code>: Return EXDEV as normal.</li> <li><code>link-exdev=rel-symlink</code>: A relative path from the newpath.</li> <li><code>link-exdev=abs-base-symlink</code>: An absolute value using the   underlying branch.</li> <li><code>link-exdev=abs-pool-symlink</code>: An absolute value using the mergerfs   mount point.</li> <li>Defaults to <code>passthrough</code>.</li> </ul> <p>NOTE: It is possible that some applications check the file they link. In those cases, it is possible it will error or complain.</p>"},{"location":"config/link_cow/","title":"link_cow","text":"<ul> <li><code>link_cow=true|false</code></li> <li>Defaults to <code>false</code></li> </ul> <p>This feature offers similar functionality to what cow-shell offers. </p> <p>When enabled if mergerfs is asked to open a file to write and the link count on the file is greater than 1 it will copy the file to a temporary new file and then rename it over the original. This will atomically \"break\" the link. After that it will open the new file.</p>"},{"location":"config/minfreespace/","title":"minfreespace","text":"<p>default: <code>4G</code></p> <p><code>minfreespace</code> is used to set a minimum free space threshold when running create policies. Any branch with free space less than the <code>minfreespace</code> value will be skipped. This is the global default but individual branches can have their own value..</p> <p>This is useful for a couple reasons.</p> <ul> <li>Since mergerfs does not split files across branches it is best to   leave space to write a newly created file on a branch to minimize   the risk of running out of space and needing   moveonenospc.</li> <li>Some filesystems' performance degrades when filled. <code>minfreespace</code>   provides a buffer so they are less likely to be filled.</li> <li>Similar to <code>ext4</code>'s reserved space option it minimizes the problems   that come from running out of space.</li> </ul>"},{"location":"config/moveonenospc/","title":"moveonenospc","text":"<p>When writing to a file a number of errors are possible. The <code>ENOSPC</code> error indicates their is no room for the data. That could be true due to the filesystem having actually no available space for data, or because a secondary resource (such as inodes) has been used up, or the filesystem might have a quota feature that is limiting how much storage a particular user may use, or (as on <code>ext4</code> there might be a feature which reserves space for privileged processes.</p> <p>Since mergerfs does not offer splitting of files across filesystems there are situations where a file is opened or created on a filesystem which is nearly full and eventually receives a <code>ENOSPC</code> error despite the pool having capacity. The <code>moveonenospc</code> feature allows the user to have some control over this situation.</p> <p>When enabled and a <code>write</code> fails with <code>ENOSPC</code> or <code>EDQUOT</code> mergerfs will:</p> <ol> <li>Run the policy defined by <code>moveonenospc</code> to find a target branch.</li> <li>\"Move\"    the file from the source branch to the target branch.</li> <li>Retry the <code>write</code> and continue on as normal.</li> </ol> <p>If at any point something fails the progress so far will be cleaned up as appropriate and the original error returned.</p> <p>If <code>moveonenospc</code> is disabled the underlying error will be returned.</p> <p>NOTE: This feature has NO affect on policies. It ONLY applies to the literal write function. If the create function returns <code>ENOSPC</code> or the policy returns <code>ENOSPC</code> that error will be returned back to the application making the <code>create</code> request.</p>"},{"location":"config/moveonenospc/#additional-reading","title":"Additional Reading","text":"<ul> <li>Functions, Categories, Policies</li> <li>Why do I get an \"out of space\" / \"no space left on device\" / ENOSPC   error even though there appears to be lots of space   available?</li> </ul>"},{"location":"config/nfsopenhack/","title":"nfsopenhack","text":"<ul> <li><code>nfsopenhack=off</code>: No hack applied.</li> <li><code>nfsopenhack=git</code>: Apply hack if path includes <code>/.git/</code>.</li> <li><code>nfsopenhack=all</code>: Apply hack on all empty read-only files opened   for writing.</li> <li>Defaults to <code>off</code>.</li> </ul> <p>NFS is not fully POSIX compliant and historically certain behaviors, such as opening files with <code>O_EXCL</code>, are not or not well supported. When mergerfs (or any FUSE filesystem) is exported over NFS some of these issues come up due to how NFS and FUSE interact.</p> <p>This hack addresses the issue where the creation of a file with a read-only mode but with a read/write or write only flag. Normally this is perfectly valid but NFS chops the one open call into multiple calls. Exactly how it is translated depends on the configuration and versions of the NFS server and clients but it results in a permission error because a normal user is not allowed to open a read-only file as writable.</p> <p>Even though it's a more niche situation this hack breaks normal security and behavior and as such is <code>off</code> by default. If set to <code>git</code> it will only perform the hack when the path in question includes <code>/.git/</code>.  <code>all</code> will result in it applying anytime a read-only file which is empty is opened for writing.</p>"},{"location":"config/nullrw/","title":"nullrw","text":"<ul> <li><code>nullrw=true|false</code></li> <li>Defaults to <code>false</code>.</li> </ul> <p>Due to how FUSE works there is an overhead to all requests made to a FUSE filesystem that wouldn't exist for an in kernel one. Meaning that even a simple passthrough will have some slowdown. However, generally the overhead is minimal in comparison to the cost of the underlying I/O. By disabling the underlying I/O we can test the theoretical performance boundaries.</p> <p>By enabling <code>nullrw</code> mergerfs will work as it always does except that all reads and writes will be no-ops. A write will succeed (the size of the write will be returned as if it were successful) but mergerfs does nothing with the data it was given. Similarly a read will return the size requested but won't touch the buffer.</p> <p>See the benchmarking section for suggestions on how to test.</p>"},{"location":"config/options/","title":"Options","text":"<p>mergerfs has many options to control it many features. For the average use case the options listed in the quickstart are sufficient. Most options are related to operating system or filesystem related concepts so having a basic background in such things is recommended for more advanced configurations.</p> <p>These option names and values are the same regardless of whether you use them with the <code>mergerfs</code> commandline program, in fstab, or in a config file.</p>"},{"location":"config/options/#types","title":"types","text":"<ul> <li>BOOL = 'true' | 'false'</li> <li>INT = [MIN_INT,MAX_INT]</li> <li>UINT = [0,MAX_INT]</li> <li>SIZE = 'NNM'; NN = INT, M = 'B' | 'K' | 'M' | 'G' | 'T'</li> <li>PAGESIZE = UINT (representing number of pages) | SIZE (in bytes   which will be converted to pages)</li> <li>STR = string (may refer to an enumerated value, see details of   argument)</li> <li>FUNC = filesystem function</li> <li>CATEGORY = function category</li> <li>POLICY = mergerfs function policy</li> </ul>"},{"location":"config/options/#mount-options","title":"mount options","text":"<ul> <li>config: Path to a config file. Same arguments as below in   key=val / ini style format.</li> <li>branches: Colon delimited list of branches. Used   primarily in config file.</li> <li>minfreespace=SIZE: The minimum available   space of a branch necessary to be considered for a create   policy. This is a default value   applied to all branches and can be overwritten when configuring   branches. Understands 'K', 'M', and 'G' to represent   kilobyte, megabyte, and gigabyte respectively. (default: 4G)</li> <li>moveonenospc=BOOL|POLICY: When enabled if a   write fails with ENOSPC (no space left on device) or   EDQUOT (disk quota exceeded) the policy selected will run to   find a new location for the file. An attempt to move the file to   that branch will occur (keeping all metadata possible) and if   successful the original is unlinked and the write retried. (default:   pfrd)</li> <li>inodecalc=passthrough|path-hash|devino-hash|hybrid-hash:   Selects the inode calculation algorithm. (default: hybrid-hash)</li> <li>dropcacheonclose=BOOL: When a file is requested to be closed   call <code>posix_fadvise</code> on it first to instruct the kernel that we no   longer need the data and it can drop its cache. Recommended when   cache.files=partial|full|auto-full|per-process to limit double   caching. (default: false)</li> <li>direct-io-allow-mmap=BOOL: On newer kernels (&gt;= 6.6) it is   possible to disable file page caching while still allowing for   shared mmap support. mergerfs will enable this feature if available   but an option is provided to turn it off for testing and debugging   purposes. (default: true)</li> <li>symlinkify=BOOL: When enabled and a file is not   writable and its mtime or ctime is older than symlinkify_timeout   files will be reported as symlinks to the original files. Please   read more below before using. (default: false)</li> <li>symlinkify_timeout=UINT: Time to wait, in   seconds, to activate the symlinkify behavior. (default: 3600)</li> <li>nullrw=BOOL: Turns reads and writes into no-ops. The request   will succeed but do nothing. Useful for benchmarking   mergerfs. (default: false)</li> <li>lazy-umount-mountpoint=BOOL: mergerfs will attempt to \"lazy   umount\" the mountpoint before mounting itself. Useful when   performing live upgrades of mergerfs. May not work on   FreeBSD. (default: false)</li> <li>ignorepponrename=BOOL: Ignore path preserving on   rename. Typically rename and link act differently depending on the   policy of <code>create</code> (read below). Enabling this will cause rename and   link to always use the non-path preserving behavior. This means   files, when renamed or linked, will stay on the same   filesystem. (default: false)</li> <li>export-support=BOOL: Sets a low-level FUSE   feature intended to indicate the filesystem can support being   exported via NFS. (default: true)</li> <li>security_capability=BOOL: If false return ENOATTR when xattr   security.capability is queried. (default: true)</li> <li>xattr=passthrough|noattr|nosys: Runtime control of   xattrs. Default is to passthrough xattr requests. 'noattr' will   short circuit as if nothing exists. 'nosys' will respond with ENOSYS   as if xattrs are not supported or disabled. (default: passthrough)</li> <li>link_cow=BOOL: When enabled if a regular file is   opened which has a link count &gt; 1 it will copy the file to a   temporary file and rename over the original. Breaking the link and   providing a basic copy-on-write function similar to   cow-shell. (default: false)</li> <li>statfs=base|full: Controls how statfs works. 'base'   means it will always use all branches in statfs calculations. 'full'   is in effect path preserving and only includes branches where the   path exists. (default: base)</li> <li>statfs_ignore=none|ro|nc: 'ro' will cause statfs calculations to   ignore available space for branches mounted or tagged as 'read-only'   or 'no create'. 'nc' will ignore available space for branches tagged   as 'no create'. (default: none)</li> <li>nfsopenhack=off|git|all: A workaround for exporting mergerfs   over NFS where there are issues with creating files for write while   setting the mode to read-only. (default: off)</li> <li>branches-mount-timeout=UINT: Number of seconds to wait at   startup for branches to be a mount other than the mountpoint's   filesystem. (default: 0)</li> <li>follow-symlinks=never|directory|regular|all:   Turns symlinks into what they point to. (default: never)</li> <li>link-exdev=passthrough|rel-symlink|abs-base-symlink|abs-pool-symlink:   When a link fails with EXDEV optionally create a symlink to the file   instead.</li> <li>rename-exdev=passthrough|rel-symlink|abs-symlink:   When a rename fails with EXDEV optionally move the file to a special   directory and symlink to it.</li> <li>readahead=UINT: Set readahead (in kilobytes) for   mergerfs and branches if greater than 0. (default: 0)</li> <li>posix_acl=BOOL: Enable POSIX ACL support (if supported by kernel   and underlying filesystem). (default: false)</li> <li>async_read=BOOL: Perform reads asynchronously. If disabled or   unavailable the kernel will ensure there is at most one pending read   request per file handle and will attempt to order requests by   offset. (default: true)</li> <li>fuse_msg_size=PAGESIZE: Set the max number of   pages per FUSE message. Only available on Linux &gt;= 4.20 and ignored   otherwise. (min: 1; max: 65535; default: \"1M\")</li> <li>threads=INT: Number of threads to use. When used   alone (<code>process-thread-count=-1</code>) it sets the number of threads   reading and processing FUSE messages. When used together it sets the   number of threads reading from FUSE. When set to zero it will   attempt to discover and use the number of logical cores. If the   thread count is set negative it will look up the number of cores   then divide by the absolute value. ie. threads=-2 on an 8 core   machine will result in 8 / 2 = 4 threads. There will always be at   least 1 thread. If set to -1 in combination with   <code>process-thread-count</code> then it will try to pick reasonable values   based on CPU thread count. NOTE: higher number of threads increases   parallelism but usually decreases throughput. (default: 0)</li> <li>read-thread-count=INT: Alias for <code>threads</code>.</li> <li>process-thread-count=INT: Enables separate thread   pool to asynchronously process FUSE requests. In this mode   <code>read-thread-count</code> refers to the number of threads reading FUSE   messages which are dispatched to process threads. -1 means disabled   otherwise acts like <code>read-thread-count</code>. (default: -1)</li> <li>process-thread-queue-depth=UINT: Sets the number   of requests any single process thread can have queued up at one   time. Meaning the total memory usage of the queues is queue depth   multiplied by the number of process threads plus read thread   count. 0 sets the depth to the same as the process thread   count. (default: 0)</li> <li>pin-threads=STR: Selects a strategy to pin   threads to CPUs (default: unset)</li> <li>flush-on-close=never|always|opened-for-write:   Flush data cache on file close. Mostly for when writeback is enabled   or merging network filesystems. (default: opened-for-write)</li> <li>scheduling-priority=INT: Set mergerfs' scheduling   priority. Valid values range from -20 to 19. See <code>setpriority</code> man   page for more details. (default: -10)</li> <li>fsname=STR: Sets the name of the filesystem as seen in   mount, df, etc. Defaults to a list of the source paths   concatenated together with the longest common prefix removed.</li> <li>func.FUNC=POLICY: Sets the   specific FUSE function's policy. See below for the list of value   types. Example: func.getattr=newest</li> <li>func.readdir=seq|cosr|cor|cosr:INT|cor:INT: Sets <code>readdir</code>   policy. INT value sets the number of threads to use for   concurrency. (default: seq)</li> <li>category.action=POLICY: Sets   policy of all FUSE functions in the action category. (default:   epall)</li> <li>category.create=POLICY: Sets   policy of all FUSE functions in the create category. (default:   pfrd)</li> <li>category.search=POLICY: Sets   policy of all FUSE functions in the search category. (default: ff)</li> <li>cache.statfs=UINT: 'statfs' cache   timeout in seconds. (default: 0)</li> <li>cache.attr=UINT: File attribute cache   timeout in seconds. (default: 1)</li> <li>cache.entry=UINT: File name lookup cache   timeout in seconds. (default: 1)</li> <li>cache.negative_entry=UINT:   Negative file name lookup cache timeout in seconds. (default: 0)</li> <li>cache.files=off|partial|full|auto-full|per-process:   File page caching mode (default: off)</li> <li>cache.files.process-names=LIST: A pipe | delimited list of   process comm   names to enable page caching for when   <code>cache.files=per-process</code>. (default: \"rtorrent|qbittorrent-nox\")</li> <li>cache.writeback=BOOL: Enable kernel   writeback caching (default: false)</li> <li>cache.symlinks=BOOL: Cache symlinks (if   supported by kernel) (default: false)</li> <li>cache.readdir=BOOL: Cache readdir (if   supported by kernel) (default: false)</li> <li>parallel-direct-writes=BOOL: Allow the kernel to dispatch   multiple, parallel (non-extending) write requests for files opened   with <code>cache.files=per-process</code> (if the process is not in   <code>process-names</code>) or <code>cache.files=off</code>. (Is a kernel feature added in   v6.2) (default: true)</li> </ul> <p>NOTE: Options are evaluated in the order listed so if the options are func.rmdir=rand,category.action=ff the action category setting will override the rmdir setting.</p> <p>NOTE: Always look at the documentation for the version of mergerfs you're using. Not all features are available in older releases.</p>"},{"location":"config/pin-threads/","title":"pin-threads","text":"<p>Simple strategies for pinning read and/or process threads. If process threads are not enabled then the strategy simply works on the read threads. Invalid values are ignored.</p> <ul> <li><code>pin-threads=R1L</code>: All read threads pinned to a single logical CPU.</li> <li><code>pin-threads=R1P</code>: All read threads pinned to a single physical CPU.</li> <li><code>pin-threads=RP1L</code>: All read and process threads pinned to a single logical CPU.</li> <li><code>pin-threads=RP1P</code>: All read and process threads pinned to a single physical CPU.</li> <li><code>pin-threads=R1LP1L</code>: All read threads pinned to a single logical   CPU, all process threads pinned to a (if possible) different logical   CPU.</li> <li><code>pin-threads=R1PP1P</code>: All read threads pinned to a single physical   CPU, all process threads pinned to a (if possible) different logical   CPU.</li> <li><code>pin-threads=RPSL</code>: All read and process threads are spread across   all logical CPUs.</li> <li><code>pin-threads=RPSP</code>: All read and process threads are spread across   all physical CPUs.</li> <li><code>pin-threads=R1PPSP</code>: All read threads are pinned to a single   physical CPU while process threads are spread across all other   physical CPUs.</li> </ul>"},{"location":"config/readahead/","title":"readahead","text":"<p>Sets the mergerfs and underlying filesystem <code>readahead</code> values. The value unit is in kibibytes.</p> <ul> <li><code>readahead=1024</code></li> </ul> <p>While the max size of messages sent between the kernel and mergerfs is configurable via the fuse_msg_size option that doesn't mean that is the size used by the kernel for read and writes.</p> <p>Linux has a max read/write size of 2GB. Since the max FUSE message size is just over 1MiB (by default on more recent kernels) the kernel will break up read and write requests with buffers larger than that 1MiB.</p> <p>When page caching is disabled (<code>cache.files=off</code>), besides the kernel breaking up requests with larger buffers, requests are effectively one for one to mergerfs. A read or write request for X bytes is made to the kernel and a request for X bytes is made to mergerfs. No readahead behavior will occur because there is no page cache available for it to store that data. In FUSE this is referred to as \"direct IO\". Note that \"direct IO\" is not the same as <code>O_DIRECT</code>.</p> <p>When page caching is enabled the kernel can and will utilize <code>readahead</code>. However, there are two values which impact the size of the <code>readahead</code> requests. The filesystem's <code>readahead</code> value and the FUSE <code>max_readahead</code> value. Whichever is lowest is used. The default <code>max_readahead</code> in mergerfs is maxed out meaning only the filesystem <code>readahead</code> value is relevant.</p> <p>Preferably this value would be set by the user externally since it is a generic feature but there is no standard way to do so mergerfs added this feature to make it easier to set.</p> <p>There is currently no way to set separate values for different branches through mergerfs. In fact at some point the feature may be changed to only set mergerfs' readahead.</p>"},{"location":"config/rename-exdev/","title":"rename-exdev","text":"<p>If using path preservation and a  <code>rename</code>  fails with <code>EXDEV</code>:</p> <ol> <li>Move file from <code>/branch/a/b/c</code> to <code>/branch/.mergerfs_rename_exdev/a/b/c</code>.</li> <li>symlink the rename's <code>newpath</code> to the moved file.</li> </ol> <p>The  <code>target</code>  value is determined by the value of  <code>rename-exdev</code>.</p> <ul> <li><code>rename-exdev=passthrough</code>: Return <code>EXDEV</code> as normal.</li> <li><code>rename-exdev=rel-symlink</code>: A relative path from the  <code>newpath</code>.</li> <li><code>rename-exdev=abs-symlink</code>: An absolute value using the mergerfs   mount point.</li> <li>Defaults to <code>passthrough</code>.</li> </ul> <p>NOTE: It is possible that some applications check the file they rename. In those cases it is possible it will error or complain.</p> <p>NOTE: The reason <code>abs-symlink</code> is not split into two like <code>link-exdev</code> is due to the complexities in managing absolute base symlinks when multiple <code>oldpaths</code> exist.</p>"},{"location":"config/rename_and_link/","title":"rename and link","text":"<p><code>rename</code> and <code>link</code> are arguably the most complicated functions to create in a union filesystem. <code>rename</code> only works within a single filesystem or device. If a <code>rename</code> can not be done due to the source and destination paths existing on different mount points it will return an error (EXDEV, cross device / improper link). So if a <code>rename</code>'s source and target are on different filesystems within the pool it creates an issue.</p> <p>Originally mergerfs would return EXDEV whenever a rename was requested which was cross directory in any way. This made the code simple and was technically compliant with POSIX requirements. However, many applications fail to handle EXDEV at all and treat it as a normal error or otherwise handle it poorly. Such apps include: gvfsd-fuse v1.20.3 and prior, Finder / CIFS/SMB client in Apple OSX 10.9+, NZBGet, Samba's recycling bin feature.</p> <p>As a result a compromise was made in order to get most software to work while still obeying mergerfs' policies. The behavior is explained below.</p> <ul> <li>If using a create policy which tries to preserve directory paths (epff,eplfs,eplus,epmfs)<ul> <li>Using the rename policy get the list of files to rename</li> <li>For each file attempt rename:<ul> <li>If failure with ENOENT (no such file or directory) run create policy</li> <li>If create policy returns the same branch as currently evaluating then clone the path</li> <li>Re-attempt rename</li> </ul> </li> <li>If any of the renames succeed the higher level rename is considered a success</li> <li>If no renames succeed the first error encountered will be returned</li> <li>On success:</li> <li>Remove the target from all branches with no source file</li> <li>Remove the source from all branches which failed to rename</li> </ul> </li> <li>If using a create policy which does not try to preserve directory paths<ul> <li>Using the rename policy get the list of files to rename</li> <li>Using the getattr policy get the target path</li> <li>For each file attempt rename:<ul> <li>If the target path does not exist on the source branch:<ul> <li>Clone target path from target branch to source branch</li> </ul> </li> <li>rename</li> </ul> </li> <li>If any of the renames succeed the higher level rename is considered a success</li> <li>If no renames succeed the first error encountered will be returned</li> <li>On success:</li> <li>Remove the target from all branches with no source file</li> <li>Remove the source from all branches which failed to rename</li> </ul> </li> </ul> <p>The removals are subject to normal entitlement checks. If the unlink fails it will fail silently.</p> <p>The above behavior will help minimize the likelihood of EXDEV being returned but it will still be possible.</p> <p>link uses the same strategy but without the removals.</p>"},{"location":"config/rename_and_link/#additional-reading","title":"Additional Reading","text":"<ul> <li>Do hardlinks work?</li> <li>How does mergerfs handle moving and copying of files?</li> <li>Why are file moves and renames failing?</li> </ul>"},{"location":"config/statfs/","title":"statfs / statvfs","text":"<ul> <li><code>statfs=base</code>: Aggregate details from all branches using their base directory.</li> <li><code>statfs=full</code>: Aggregate details using the full path of the file   requested. Limiting it to only branches where the file exists.</li> <li>Defaults to <code>base</code>. </li> </ul> <p>statvfs normalizes the source filesystems based on the fragment size and sums the number of adjusted blocks and inodes. This means you will see the combined space of all sources. Total, used, and free. The sources however are dedupped based on the filesystem so multiple sources on the same drive will not result in double counting its space. Other filesystems mounted further down the tree of the branch will not be included when checking the mount's stats.</p>"},{"location":"config/statfs/#statfs_ignore","title":"statfs_ignore","text":"<p>Modifies how <code>statfs</code> works. Will cause it to ignore branches of a certain mode.</p> <ul> <li><code>statfs_ignore=none</code>: Include all branches.</li> <li><code>statfs_ignore=ro</code>: Ignore available space for branches mounted as   read-only or have a mode <code>RO</code> or <code>NC</code>.</li> <li><code>statfs_ignore=nc</code>: Ignore available space for branches with a mode   of <code>NC</code>.</li> <li>Defaults to <code>none</code>.</li> </ul>"},{"location":"config/symlinkify/","title":"symlinkify","text":"<ul> <li><code>symlinkify=true|false</code></li> <li>Defaults to <code>false</code>.</li> </ul> <p>Due to the levels of indirection introduced by mergerfs and the underlying technology FUSE there can be varying levels of performance degradation. This feature will turn non-directories which are not writable into symlinks to the original file found by the <code>readlink</code> policy after the mtime and ctime are older than the timeout.</p> <p>WARNING: The current implementation has a known issue in which if the file is open and being used when the file is converted to a symlink then the application which has that file open will receive an error when using it. This is unlikely to occur in practice but is something to keep in mind.</p> <p>WARNING: Some backup solutions, such as CrashPlan, do not backup the target of a symlink. If using this feature it will be necessary to point any backup software to the original filesystems or configure the software to follow symlinks if such an option is available. Alternatively, create two mounts. One for backup and one for general consumption.</p>"},{"location":"config/threads/","title":"threads","text":"<p>There are multiple thread pools used in mergerfs to provide parallel behaviors.</p>"},{"location":"config/threads/#read-thread-count","title":"read-thread-count","text":"<p>Defaults to <code>0</code></p> <p>The number of threads used to read messages from the kernel. If used alone processing will be done on the same thread. If <code>process-thread-count</code> is enabled then this thread pool will read messages and the process thread pool will do the work. This can increase how much mergerfs can process at one time but may reduce throughput.</p> <ul> <li><code>read-thread-count=0</code> and <code>process-thread-count=-1</code>: Create <code>1</code>   read+process thread per logical CPU core upto <code>8</code>.</li> <li><code>read-thread-count=N</code> where <code>N&gt;0</code> and <code>process-thread-count=-1</code>:   Create a thread pool of <code>N</code> read+process threads.</li> <li><code>read-thread-count=N</code> where <code>N&lt;0</code> and <code>process-thread-count=-1</code>:   Create a read+process thread pool of <code>CPUCount / -N</code>   threads. Minimum of <code>1</code>.</li> <li><code>read-thread-count=0</code> and <code>process-thread-count=0</code>: Create <code>2</code> read   threads and a process thread per logical CPU core upto <code>8</code>.</li> <li><code>read-thread-count=0</code> and <code>process-thread-count!=-1</code>: Creates <code>2</code>   read threads and number of process threads as defined below.</li> </ul>"},{"location":"config/threads/#process-thread-count","title":"process-thread-count","text":"<p>Defaults to <code>-1</code></p> <p>When enabled this sets the number of threads in the message processing pool.</p> <ul> <li><code>process-thread-count=-1</code>: Process thread pool is disabled.</li> <li><code>process-thread-count=0</code>: Create <code>1</code> thread process thread per   logical CPU core upto <code>8</code>.</li> <li><code>process-thread-count=N</code> where <code>N&gt;0</code>: Create a thread pool of <code>N</code> threads.</li> <li><code>process-thread-count=N</code> where <code>N&lt;-1</code>: Create a thread pool of <code>CPUCount /   -N</code> threads. Minimum of 1.</li> </ul>"},{"location":"config/threads/#process-thread-queue-depth","title":"process-thread-queue-depth","text":"<p>Defaults to <code>2</code></p> <p>Sets the depth queue for the processing thread queue per thread. Meaning if the read threads are getting requests faster than can be processed they will be queued up upto the queue depth. Despite the calculation being per thread the queue depth is shared across all in the pool.</p> <ul> <li><code>process-thread-queue-depth=N</code> where <code>N&gt;0</code>: Sets the number of   outstanding requests that the process thread pool can have to <code>N *   process-thread-count</code>. If requests come in faster than can be   processed and the max queue depth hit then queuing the request will   block in order to limit memory growth.</li> <li><code>process-thread-queue-depth&lt;=0</code>: Sets the queue depth to 2. May be   used in the future to set dynamically.</li> </ul>"},{"location":"config/xattr/","title":"xattr","text":"<ul> <li><code>xattr=passthrough</code>: Passes through all requests to underlying file.</li> <li><code>xattr=noattr</code>: mergerfs receives the request but returns <code>NOATTR</code>.</li> <li><code>xattr=nosys</code>: Tells the kernel to reject all <code>xattr</code> requests.</li> <li>Defaults to <code>passthrough</code>.</li> </ul> <p>Runtime extended attribute support can be managed via the <code>xattr</code> option. By default it will passthrough any xattr calls. Given xattr support is rarely used and can have significant performance implications mergerfs allows it to be disabled at runtime. The performance problems mostly comes when file caching is enabled. The kernel will send a <code>getxattr</code> for <code>security.capability</code> before every single write. It doesn't cache the responses to any <code>getxattr</code>. This might be addressed in the future but for now mergerfs can really only offer the following workarounds.</p> <p><code>noattr</code> will cause mergerfs to short circuit all xattr calls and return ENOATTR where appropriate. mergerfs still gets all the requests but they will not be forwarded on to the underlying filesystems. The runtime control will still function in this mode.</p> <p><code>nosys</code> will cause mergerfs to return <code>ENOSYS</code> for any xattr call. The difference with <code>noattr</code> is that the kernel will cache this fact and itself short circuit future calls. This is more efficient than <code>noattr</code> but will cause mergerfs' runtime control via the hidden file to stop working.</p>"},{"location":"faq/compatibility_and_integration/","title":"Compatibility and Integration","text":""},{"location":"faq/compatibility_and_integration/#what-operating-systems-does-mergerfs-support","title":"What operating systems does mergerfs support?","text":"<p>Primarily Linux. FreeBSD is casually supported but not well tested.</p> <p>With FreeBSD certain Linux functions and FUSE features are not supported. In many cases the absense will not be noticed however performance may be impacted due to a core mergerfs design decision relying on a Linux feature.</p> <p>Linux allows individual threads to change credentials whereas FreeBSD does not. As a result mergerfs must use a lock to ensure critical sections which need to change credentials are safeguarded. This will limit throughput on systems where requests to mergerfs come from multiple user identities.</p>"},{"location":"faq/compatibility_and_integration/#why-not-support-macos","title":"Why not support MacOS?","text":"<ul> <li>Last checked the support for FUSE on MacOS was in flux.</li> <li>MacOS is not an OS commonly used for NASs and other use cases   for which mergerfs is used.</li> <li>trapexit does not own a MacOS based system.</li> </ul>"},{"location":"faq/compatibility_and_integration/#why-not-support-windows","title":"Why not support Windows?","text":"<p>WinFSP does implement a libfuse compatible API for Windows however mergerfs does not use libfuse (perhaps ironically.) Even if mergerfs was ported to use libfuse it would require the use of the low level API. WinFSP does not appear to support libfuse's low level API.</p> <p>Windows, while used for NAS systems more often than MacOS, is still relatively uncommon when compared to Linux. Drive Pool is a reasonable alternative.</p>"},{"location":"faq/compatibility_and_integration/#what-filesystems-can-be-used-as-branches","title":"What filesystems can be used as branches?","text":"<p>ext4, btrfs, xfs, f2fs, zfs, nfs, etc.</p> <p>On the surface any filesystem should work but there could be issues with non-POSIX compliant filesystems such as vfat, ntfs, cifs, exfat, etc. When directories need to be created or files moved by mergerfs if the filesystem returns errors due to not supporting certain POSIX filesystem features it could result in the core functions failing.</p> <p>Since mergerfs is not generally used with non-POSIX filesystems this has not been a problem for users and there are some checks for known edgecases but it is possible some are not accounted for. If use with a filesystem results in issues please file a ticket with the details.</p>"},{"location":"faq/compatibility_and_integration/#can-i-use-mergerfs-without-snapraid-snapraid-without-mergerfs","title":"Can I use mergerfs without SnapRAID? SnapRAID without mergerfs?","text":"<p>Yes. They are completely unrelated pieces of software that just happen to work well together.</p>"},{"location":"faq/compatibility_and_integration/#does-mergerfs-support-cow-copy-on-write-writes-to-read-only-filesystems","title":"Does mergerfs support CoW / copy-on-write / writes to read-only filesystems?","text":"<p>Not in the sense of a filesystem like BTRFS or ZFS nor in the overlayfs or aufs sense. It does offer a cow-shell like hard link breaking (copy to temp file then rename over original) which can be useful when wanting to save space by hardlinking duplicate files but wish to treat each name as if it were a unique and separate file.</p> <p>If you want to write to a read-only filesystem you should look at overlayfs. You can always include the overlayfs mount into a mergerfs pool.</p>"},{"location":"faq/compatibility_and_integration/#can-mergerfs-run-via-docker-podman-kubernetes-etc","title":"Can mergerfs run via Docker, Podman, Kubernetes, etc.","text":"<p>Yes. With Docker you'll need to include <code>--cap-add=SYS_ADMIN --device=/dev/fuse --security-opt=apparmor:unconfined</code> or similar with other container runtimes. You should also be running it as root or given sufficient caps to allow mergerfs to change user and group identity as well as have root like filesystem permissions. This ability is critical to how mergerfs works.</p> <p>Also, as mentioned by hotio, with Docker you should probably be mounting with <code>bind-propagation</code> set to <code>slave</code>.</p>"},{"location":"faq/compatibility_and_integration/#how-does-mergerfs-interact-with-user-namespaces","title":"How does mergerfs interact with user namespaces?","text":"<p>FUSE does not have any special integration with Linux user namespaces used by container runtime platforms like Docker, Podman, etc. The uid/gid values passed to mergerfs will be the host level values rather than that seen inside the container. Meaning <code>root</code> in a container with user namespaces configured will not be <code>root</code> to mergerfs. Same with any other uid/gid. Meaning your permissions on your branches must work with the translated values from the id mapping.</p> <p>It is generally recommended to not use user namespacing / id mapping given the complication it introduces.</p>"},{"location":"faq/compatibility_and_integration/#can-mergerfs-be-used-with-nfs-root-squash","title":"Can mergerfs be used with NFS root squash?","text":"<p>If mergerfs is pooling a NFS mount then root squash should be disabled as mergerfs needs to be able to have elevated privileges to do what it does.</p> <p>If you are exporting mergerfs over NFS then it is not really necessary.</p> <p>See the section on remote filesystems.</p>"},{"location":"faq/compatibility_and_integration/#does-inotify-and-fanotify-work","title":"Does inotify and fanotify work?","text":"<p>Yes. You can test by using inotifywait or inotifywatch.</p> <p>However, you can not get notifications for events that occur outside of the mergerfs mount. For instance if you are doing out-of-band changes it is not possible to get those events forwarded through mergerfs. FUSE offers no mechanism to publish events and even if it did it would require somewhat expensive inotify or fanotify watches on all branches.</p> <p>Most software which has the ability to actively monitor a filesystem (such as Plex, Emby, Jellyfin, Airsonic, etc.) are using <code>inotify</code> or <code>fanotify</code>.</p> <p>If you must add content out-of-band the only way to get real-time updates (via inotify or fanotify) is to add the underlying branches to the software rather than using the mergerfs mount. An alternative is to enable regular library scanning. Plex, for instance, has \"Scan my library periodically\". Additionally, if you are using software such as Radarr, Sonarr, or Lidarr you can configure it to trigger library updates in a number of services. This can be found under <code>Settings &gt; Connect</code>.</p>"},{"location":"faq/configuration_and_policies/","title":"Configuration and Policies","text":""},{"location":"faq/configuration_and_policies/#what-settings-should-i-use","title":"What settings should I use?","text":"<p>Depends on what features you want. Generally, there are no \"good\", \"bad\", \"inefficient\", or \"optimal\" settings. Options are almost exclusively functional. Meaning they change the behavior of the software. It is best to read over the available options and choose what fits your use case. If something is not clear from the documentation please reach out and the documentation will be improved.</p> <p>The settings described in the Quick Start are sufficient for most users.</p> <p>Filesystems are complex and use cases numerous. There simply is no way to provide a singular setup that works for all situations. Since mergerfs does not impact the underlying filesystems and can be added or removed without any impact it is extremely easy to test and experiment with different settings.</p>"},{"location":"faq/configuration_and_policies/#why-is-pfrd-the-default-create-policy","title":"Why is pfrd the default create policy?","text":"<p>Originally the default was <code>epmfs</code> however it was found to cause significant confusion among new users who expected mergerfs to always choose a branch with available space. For mergerfs v2.41.0 it was decided to change the default to the less restrictive policy <code>pfrd</code>.</p>"},{"location":"faq/configuration_and_policies/#how-can-i-ensure-files-are-collocated-on-the-same-branch","title":"How can I ensure files are collocated on the same branch?","text":"<p>Many people like the idea of ensuring related files, such as all the files to a TV show season or songs in an album, are stored on the same storage device. However, most people have no actual need for this behavior.</p> <ol> <li>If you backup your data it is extremely likely your backup solution    can restore only those files you are missing.</li> <li>Software such as Sonarr can manage the downloading and post    processing of bespoke episodes which may be missing in a    season. Either by downloading the episode individually if available    or by downloading a full season.</li> <li>There is no benefit to keeping files collocated with regard to    drive spinup, caching, or other secondary concern.</li> </ol> <p>The main use case for wanting collocation is where the branch is going to be removed from the pool and you wish to have all data from some logical set on that device. Such as you intend to take a drive out of the pool to take on a trip and want a whole show on the drive. However, even in these situations you typically end up needing to curate the files anyway because it has show A but not show B.</p> <p>All that said you can accomplish collocation to varying degrees using the following methods:</p> <ol> <li>Use    mergerfs.consolidate    when consolidation is needed.</li> <li>Use a <code>msp</code> create policy.</li> <li>Use <code>epmfs</code> or other <code>ep</code> create policy and manually create paths    on the branches directly.</li> <li>Use a <code>ep</code> <code>create</code> policy and <code>rand</code> for <code>mkdir</code>.</li> </ol>"},{"location":"faq/configuration_and_policies/#how-can-i-balance-files-across-the-pool","title":"How can I balance files across the pool?","text":"<p>Similar to collocation there is generally little reason to balance files.</p> <ol> <li>Since prediction of a filesystem's death or loss of data is near    impossible there is little reason to balance in hopes of limiting    data loss.</li> <li>While performance could be impacted by having too much reading or    writing happen to singular underlying filesystems balancing won't    help unless you have the ability to manage the access patterns to    the pool.</li> <li>Over time most configurations will lead to a random distribution of    files across the branches which is effectively \"balancing.\"</li> </ol> <p>If you wish to move files around or balance the pool you can:</p> <ol> <li>Use <code>rand</code> or <code>pfrd</code> create policies and just use your system as    normal.</li> <li>Write simple scripts using rsync or similar to move files around as    you wish.</li> <li>Use    mergerfs.balance. Keep    in mind that this tool is really just an example of how to    accomplish such a task. The tool does not keep track of links so    you may encounter an increase in used space if you rely on links to    reduce redundancy. However, you can run a file dedup program like    rdfind to restore the links.</li> </ol>"},{"location":"faq/have_you_considered/","title":"\"Have You Considered?\"","text":""},{"location":"faq/have_you_considered/#have-you-considered-limiting-drive-spinup","title":"Have you considered limiting drive spinup?","text":"<p>Yes. See Limiting Drive Spinup.</p>"},{"location":"faq/have_you_considered/#have-you-considered-porting-to-macos","title":"Have you considered porting to MacOS?","text":"<p>Yes, but the FUSE implementation on MacOS has gotten a bit complicated and fragmented. I'm not opposed to supporting it but given the low demand, lack of the author having a modern MacOS system, the fact mergerfs does not use standard libfuse API, and MacOS FUSE situation it is unlikely.</p>"},{"location":"faq/have_you_considered/#have-you-considered-porting-mergerfs-to-windows-winfsp","title":"Have you considered porting mergerfs to Windows (WinFsp)?","text":"<p>Similar to MacOS the demand is very low and mergerfs does not use the libfuse library so porting to WinFsp would first mean porting it to <code>libfuse</code>.</p>"},{"location":"faq/limit_drive_spinup/","title":"Limiting drive spinup","text":""},{"location":"faq/limit_drive_spinup/#how-can-i-setup-my-system-to-limit-drive-spinup","title":"How can I setup my system to limit drive spinup?","text":"<p>TL;DR: You really can't. Not through mergerfs alone. In fact mergerfs makes an attempt to do so more complicated.</p> <p>mergerfs is a proxy. Despite having some caching behaviors it is not designed to cache much more than metadata. It proxies calls between client software and underlying filesystems. If a client makes a request such as <code>open</code>, <code>readdir</code>, <code>stat</code>, etc. it must translate that into something that makes sense across multiple filesystems. For <code>readdir</code> that means running the call against all branches and aggregating the output. For <code>open</code> that means finding the file to open and doing so. The only way to find the file to open is to scan across all branches and sort the results and pick one. There is no practical way to do otherwise. Especially given so many mergerfs users expect out-of-band changes to \"just work.\"</p> <p>The best way to limit spinup of drives is to limit their usage at the client level. Meaning keeping software from interacting with the filesystem (and therefore the drive) all together.</p>"},{"location":"faq/limit_drive_spinup/#what-if-you-assume-no-out-of-band-changes-and-cache-everything","title":"What if you assume no out-of-band changes and cache everything?","text":"<p>This would require a significant rewrite of mergerfs. Everything is done on the fly right now and all those calls to underlying filesystems can cause a spinup. To work around that a database of some sort would have to be used to store ALL metadata about the underlying filesystems and on startup everything scanned and stored. From then on it would have to carefully update all the same data the filesystems do. It couldn't be kept in RAM because it would take up too much space so it'd have to be on a SSD or other storage device. If anything changed out of band it would break things in weird ways. It could rescan on occasion but that would require spinning up everything. Filesystem watches could be used to get updates when the filesystem changes but that would allow for race conditions and might keep the drives from spinning down. Something as \"simple\" as keeping the current available free space on each filesystem isn't as easy as one might think given reflinks, snapshots, and other block level dedup technologies as well as the space used includes not just raw file usage.</p> <p>Even if all metadata (including xattrs) is cached some software will open files (media like videos and audio) to check their metadata. Granted a Plex or Jellyfin scan which may do that is different from a random directory listing but is still something to consider. Those \"deep\" scans can't be kept from waking drives.</p>"},{"location":"faq/limit_drive_spinup/#what-if-you-only-query-already-active-drives","title":"What if you only query already active drives?","text":"<p>Let's assume that is plausible (it isn't because some drives actually will spin up if you ask if they are spun down... yes... really) you would have to either cache all the metadata on the filesystem or treat it like the filesystem doesn't exist. The former has all the problems mentioned prior and the latter would break a lot of things.</p>"},{"location":"faq/limit_drive_spinup/#is-there-anything-that-can-be-done-where-mergerfs-is-involved","title":"Is there anything that can be done where mergerfs is involved?","text":"<p>Yes, but whether it works for you depends on your tolerance for the complexity.</p> <ol> <li>Cleanly separate writing, storing, and consuming the data.</li> <li>Use a SSD or dedicated and limited pool of drives for downloads / torrents.</li> <li>When downloaded move the files to the primary storage pool.</li> <li>When setting up software like Plex, Jellyfin, etc. point to the       underlying filesystems. Not mergerfs.</li> <li>Add a bunch of bcache, lvmcache, dm-cache, or similar block level    cache to your setup. After a bit of use, assuming sufficient    storage space, you can limit the likelihood of the underlying    spinning disks from needing to be hit.</li> </ol> <p>Remember too that while it may be a tradeoff you are willing to live with there is decent evidence that spinning down drives puts increased wear on them and can lead to their death earlier than otherwise.</p>"},{"location":"faq/recommendations_and_warnings/","title":"Recommendations and Warnings","text":""},{"location":"faq/recommendations_and_warnings/#what-should-mergerfs-not-be-used-for","title":"What should mergerfs NOT be used for?","text":"<ul> <li>databases: Even if the database stored data in separate files   (mergerfs wouldn't offer much otherwise) the higher latency of the   indirection will really harm performance. If it is a lightly used   sqlite3 database then it should be fine.</li> <li>VM images: For the same reasons as databases. VM images are accessed   very aggressively and mergerfs will introduce a lot of extra latency.</li> <li>As replacement for RAID: mergerfs is just for pooling branches. If   you need that kind of device performance aggregation or high   availability you should stick with RAID. However, it is fine to put   a filesystem which is on a RAID setup in mergerfs.</li> </ul>"},{"location":"faq/recommendations_and_warnings/#its-mentioned-that-there-are-some-security-issues-with-mhddfs-what-are-they-how-does-mergerfs-address-them","title":"It's mentioned that there are some security issues with mhddfs. What are they? How does mergerfs address them?","text":"<p>mhddfs manages running as <code>root</code> by calling getuid() and if it returns <code>0</code> then it will chown the file. Not only is that a race condition but it doesn't handle other situations. Rather than attempting to simulate POSIX ACL behavior the proper way to manage this is to use seteuid and setegid, in effect, becoming the user making the original call, and perform the action as them. This is what mergerfs does and why mergerfs should always run as root.</p> <p>In Linux setreuid syscalls apply only to the thread. glibc hides this away by using realtime signals to inform all threads to change credentials. Taking after Samba, mergerfs uses <code>syscall(SYS_setreuid,...)</code> to set the callers credentials for that thread only. Jumping back to <code>root</code> as necessary should escalated privileges be needed (for instance: to clone paths between filesystems).</p> <p>For non-Linux systems, mergerfs uses a read-write lock and changes credentials only when necessary. If multiple threads are to be user X then only the first one will need to change the processes credentials. So long as the other threads need to be user X they will take a readlock allowing multiple threads to share the credentials. Once a request comes in to run as user Y that thread will attempt a write lock and change to Y's credentials when it can. If the ability to give writers priority is supported then that flag will be used so threads trying to change credentials don't starve. This isn't the best solution but should work reasonably well assuming there are few users.</p>"},{"location":"faq/reliability_and_scalability/","title":"Reliability and Scalability","text":""},{"location":"faq/reliability_and_scalability/#is-mergerfs-production-ready","title":"Is mergerfs \"production ready?\"","text":"<p>Yes.</p> <p>mergerfs has been around for over a decade and used by many users on their systems. Typically running 24/7 with constant load.</p> <p>At least a few companies are believed to use mergerfs in production environments. A number of NAS focused operating systems includes mergerfs as a solution for pooling filesystems.</p> <p>Most serious issues (crashes or data corruption) have been due to kernel bugs. All of which are fixed in stable releases.</p>"},{"location":"faq/reliability_and_scalability/#how-well-does-mergerfs-scale","title":"How well does mergerfs scale?","text":"<p>Users have reported running mergerfs on everything from OpenWRT routers and Raspberry Pi SBCs to multi-socket Xeon enterprise servers.</p> <p>Users have pooled everything from USB thumb drives to enterprise NVME SSDs to remote filesystems and rclone mounts.</p> <p>The cost of many calls can be <code>O(n)</code> meaning adding more branches to the pool will increase the cost of certain functions, such as reading directories or finding files to open, but there are a number of caches and strategies in place to limit overhead where possible.</p>"},{"location":"faq/reliability_and_scalability/#are-there-any-limits","title":"Are there any limits?","text":"<p>There is no maximum capacity beyond what is imposed by the operating system itself. Any limit is practical rather than technical. As explained in the question about scale mergerfs is mostly limited by the tolerated cost of aggregating branches and the cost associated with interacting with them. If you pool slow network filesystem then that will naturally impact performance more than low latency SSDs.</p>"},{"location":"faq/technical_behavior_and_limitations/","title":"Technical Behavior and Limitations","text":""},{"location":"faq/technical_behavior_and_limitations/#do-hardlinks-work","title":"Do hardlinks work?","text":"<p>Yes. There is no option to enable or disable links (or renames.) They are fundamentally supported in compatible situations. That said the inode of a file is not necessarily indicative of two file names linking to the same underlying data. See also the option <code>inodecalc</code> for how inode values are calculated.</p> <p>What mergerfs does not do is fake hard links across branches. Read the section rename &amp; link for how it works.</p> <p>Remember that hardlinks will NOT work across devices. That includes between the original filesystem and a mergerfs pool, between two separate pools of the same underlying filesystems, or bind mounts of paths within the mergerfs pool. The latter is common when using Docker or Podman. Multiple volumes (bind mounts) to the same underlying filesystem are considered different devices. There is no way to link or rename between them. You should mount in the highest directory in the mergerfs pool that includes all the paths you need if you want links and rename to work.</p>"},{"location":"faq/technical_behavior_and_limitations/#how-does-mergerfs-handle-moving-and-copying-of-files","title":"How does mergerfs handle moving and copying of files?","text":"<p>This is a very common mistaken assumption regarding how filesystems work. There is no such thing as \"move\" or \"copy.\" These concepts are high level behaviors made up of numerous independent steps and not individual filesystem functions.</p> <p>A \"move\" can include a \"copy\" so lets describe copy first.</p> <p>When an application copies a file from \"source\" to \"destination\" it can do so in a number of ways but the basics are the following.</p> <ol> <li><code>open</code> the source file.</li> <li><code>create</code> the destination file.</li> <li><code>read</code> a chunk of data from source and <code>write</code> to    destination. Continue till it runs out of data to copy.</li> <li>Copy file metadata (<code>stat</code>) such as ownership (<code>chown</code>),    permissions (<code>chmod</code>), timestamps (<code>utimes</code>), extended attributes    (<code>getxattr</code>, <code>setxattr</code>), etc.</li> <li><code>close</code> source and destination files.</li> </ol> <p>\"move\" is typically a <code>rename(src,dst)</code> and if that errors with <code>EXDEV</code> (meaning the source and destination are on different filesystems) the application will \"copy\" the file as described above and then it removes (<code>unlink</code>) the source.</p> <p>The <code>rename(src,dst)</code>, <code>open(src)</code>, <code>create(dst)</code>, data copying, metadata copying, <code>unlink(src)</code>, etc. are entirely distinct and separate events. There is really no practical way to know that what is ultimately occurring is the \"copying\" of a file or what the source file would be. Since the source is not known there is no way to know how large a created file is destined to become. This is why it is impossible for mergerfs to choose the branch for a <code>create</code> based on file size. The only context provided when a file is created, besides the name, is the permissions, if it is to be read and/or written, and some low level settings for the operating system.</p> <p>All of this means that mergerfs can not make decisions when a file is created based on file size or the source of the data. That information is simply not available. At best mergerfs could respond to files reaching a certain size when writing data, a file is closed, or renamed.</p> <p>Related: if a user wished to have mergerfs perform certain activities based on the name of a file it is common and even best practice for a program to write to a temporary file first and then rename to its final destination. That temporary file name will typically be random and have no indication of the type of file being written. At best something could be done on rename.</p>"},{"location":"faq/technical_behavior_and_limitations/#does-ficlone-or-ficlonerange-work","title":"Does FICLONE or FICLONERANGE work?","text":"<p>Unfortunately not. FUSE, the technology mergerfs is based on, does not support the <code>clone_file_range</code> feature needed for it to work. mergerfs won't even know such a request is made. The kernel will simply return an error back to the application making the request.</p> <p>Should FUSE gain the ability mergerfs will be updated to support it.</p>"},{"location":"faq/technical_behavior_and_limitations/#why-does-the-total-available-space-in-mergerfs-not-equal-outside","title":"Why does the total available space in mergerfs not equal outside?","text":"<p>Are you using ext2/3/4? With reserve for root? mergerfs uses available space for statfs calculations. If you've reserved space for root then it won't show up.</p> <p>You can remove the reserve by running: <code>tune2fs -m 0 &lt;device&gt;</code></p>"},{"location":"faq/technical_behavior_and_limitations/#i-notice-massive-slowdowns-of-writes-when-enabling-cachefiles","title":"I notice massive slowdowns of writes when enabling cache.files.","text":"<p>When file caching is enabled in any form (<code>cache.files!=off</code>) it will issue <code>getxattr</code> requests for <code>security.capability</code> prior to every single write. This will usually result in performance degradation, especially when using a network filesystem (such as NFS or SMB.) Unfortunately at this moment, the kernel is not caching the response.</p> <p>To work around this situation mergerfs offers a few solutions.</p> <ol> <li>Set <code>security_capability=false</code>. It will short circuit any call and    return <code>ENOATTR</code>. This still means though that mergerfs will    receive the request before every write but at least it doesn't get    passed through to the underlying filesystem.</li> <li>Set <code>xattr=noattr</code>. Same as above but applies to all calls to    getxattr. Not just <code>security.capability</code>. This will not be cached    by the kernel either but mergerfs' runtime config system will still    function.</li> <li>Set <code>xattr=nosys</code>. Results in mergerfs returning <code>ENOSYS</code> which    will be cached by the kernel. No future xattr calls will be    forwarded to mergerfs. The downside is that also means the xattr    based config and query functionality won't work either.</li> <li>Disable file caching. If you aren't using applications which use    <code>mmap</code> it's probably simpler to just disable it altogether. The    kernel won't send the requests when caching is disabled.</li> </ol>"},{"location":"faq/technical_behavior_and_limitations/#why-use-fuse-why-not-a-kernel-based-solution","title":"Why use FUSE? Why not a kernel based solution?","text":"<p>As with any solution to a problem, there are advantages and disadvantages to each one.</p> <p>A FUSE based solution has all the downsides of FUSE:</p> <ul> <li>Higher IO latency due to the trips in and out of kernel space</li> <li>Higher general overhead due to trips in and out of kernel space</li> <li>Double caching when using page caching</li> <li>Misc limitations due to FUSE's design</li> </ul> <p>But FUSE also has a lot of upsides:</p> <ul> <li>Easier to offer a cross platform solution</li> <li>Easier forward and backward compatibility</li> <li>Easier updates for users</li> <li>Easier and faster release cadence</li> <li>Allows more flexibility in design and features</li> <li>Overall easier to write, secure, and maintain</li> <li>Much lower barrier to entry (getting code into the kernel takes a   lot of time and effort initially)</li> </ul>"},{"location":"faq/technical_behavior_and_limitations/#is-my-oss-libfuse-needed-for-mergerfs-to-work","title":"Is my OS's libfuse needed for mergerfs to work?","text":"<p>No. Normally <code>mount.fuse</code> is needed to get mergerfs (or any FUSE filesystem to mount using the <code>mount</code> command but in vendoring the libfuse library the <code>mount.fuse</code> app has been renamed to <code>mount.mergerfs</code> meaning the filesystem type in <code>fstab</code> can simply be <code>mergerfs</code>. That said there should be no harm in having it installed and continuing to using <code>fuse.mergerfs</code> as the type in <code>/etc/fstab</code>.</p> <p>If <code>mergerfs</code> doesn't work as a type it could be due to how the <code>mount.mergerfs</code> tool was installed. Must be in <code>/sbin/</code> with proper permissions.</p>"},{"location":"faq/technical_behavior_and_limitations/#why-was-splice-support-removed","title":"Why was splice support removed?","text":"<p>After a lot of testing over the years, splicing always appeared to at best, provide equivalent performance, and in some cases, worse performance. Splice is not supported on other platforms forcing a traditional read/write fallback to be provided. The splice code was removed to simplify the codebase.</p>"},{"location":"faq/technical_behavior_and_limitations/#how-does-mergerfs-handle-credentials","title":"How does mergerfs handle credentials?","text":"<p>mergerfs is a multithreaded application in order to handle requests from the kernel concurrently. Each FUSE message has a header with certain details about the request include the process ID (pid) of the requesting application, the process' effective user id (uid), and group id (gid). To ensure proper POSIX filesystem behavior and security mergerfs must change its identity to match that of the requester when performing the core filesystem function on the underlying filesystem. On most Unix/POSIX based system a process and all its threads are under the same uid and gid. However, on Linux each thread may have its own credentials. This allows mergerfs to be multithreaded and for each thread to change to the credentials (seteuid,setegid) as required by the incoming message it is handling. However, on FreeBSD this is not possible at the moment (though there has been discussions and as such must change the credentials of the whole application when actioning messages. mergerfs does optimize this behavior by only changing credentials and locking the thread to do so if the process is currently not the same as what is necessary by the incoming request.</p>"},{"location":"faq/usage_and_functionality/","title":"Usage and Functionality","text":""},{"location":"faq/usage_and_functionality/#can-mergerfs-be-used-with-filesystems-which-already-have-data","title":"Can mergerfs be used with filesystems which already have data?","text":"<p>Yes. mergerfs is really just a proxy and does NOT interfere with the normal form or function of the filesystems, mounts, or paths it manages. It literally is interacting with your filesystems as any other application does. It can not do anything that any other random piece of software can't do.</p> <p>mergerfs is not a traditional filesystem that takes control over the underlying drive, block device, or partition. mergerfs is not RAID. It does not manipulate the data that passes through it. It does not shard data across filesystems. It only shards some behavior and aggregates others.</p>"},{"location":"faq/usage_and_functionality/#can-mergerfs-be-removed-without-affecting-the-data","title":"Can mergerfs be removed without affecting the data?","text":"<p>Yes. See the previous question's answer.</p>"},{"location":"faq/usage_and_functionality/#can-filesystems-be-removed-from-the-pool-without-affecting-them","title":"Can filesystems be removed from the pool without affecting them?","text":"<p>Yes. See previous question's answer.</p> <p>This is true for planned removal by unmounting mergerfs and changing the config, changes made to mergerfs at runtime, umounting of the branch's filesystem on the fly (whether on purpose or due to error), etc.</p>"},{"location":"faq/usage_and_functionality/#what-happens-if-a-filesystem-disappears-at-runtime","title":"What happens if a filesystem disappears at runtime?","text":"<p>By \"disappear\" meaning explicitly unmounted or due to an error the OS removes it.</p> <p>Nothing explicitly happens. mergerfs works on paths, not mounts. If the branch path still exists mergerfs will treat it the same as it did before. It just may not have any data there. If the branch no longer exists it will be ignored. If the OS returns errors then mergerfs will return those errors where appropriate. See Error Handling and Logging.</p>"},{"location":"faq/usage_and_functionality/#can-filesystems-be-moved-to-another-pool","title":"Can filesystems be moved to another pool?","text":"<p>Yes.</p>"},{"location":"faq/usage_and_functionality/#can-filesystems-be-part-of-multiple-pools","title":"Can filesystems be part of multiple pools?","text":"<p>Yes.</p>"},{"location":"faq/usage_and_functionality/#how-do-i-migrate-data-into-or-out-of-the-pool-when-addingremoving-filesystems","title":"How do I migrate data into or out of the pool when adding/removing filesystems?","text":"<p>There is no need to do so. mergerfs is a union filesystem. It works on top of existing filesystems. It does not replace them. See the previous questions and answers.</p>"},{"location":"faq/usage_and_functionality/#how-do-i-remove-a-filesystem-but-keep-the-data-in-the-pool","title":"How do I remove a filesystem but keep the data in the pool?","text":"<p>Nothing special needs to be done. Remove the branch from mergerfs' config and copy (rsync) the data from the removed filesystem into the pool. The same as if it were you transferring data from one filesystem to another.</p> <p>If you wish to continue using the pool with all data available while performing the transfer simply create a temporary pool without the branch in question and then copy the data from the branch to the temporary pool. It would probably be a good idea to set the branch mode to <code>RO</code> prior to doing this to ensure no new content is written to the filesystem while performing the copy. However, it is typically good practice to run rsync or rclone again after the first copy finishes to ensure nothing is left behind.</p> <p>NOTE: Above recommends to \"copy\" rather than \"move\" because you want to ensure that your data is transferred before wiping the drive or filesystem.</p>"},{"location":"faq/usage_and_functionality/#can-filesystems-still-be-used-directly-outside-of-mergerfs-while-pooled","title":"Can filesystems still be used directly? Outside of mergerfs while pooled?","text":"<p>Yes, out-of-band interaction is generally fine. Remember that mergerfs is a userland application so any interaction with the underlying filesystem is the same as multiple normal applications interacting. However, it is not recommended to write to the same file from within the pool and from without at the same time. Especially if using page caching (<code>cache.files!=off</code>) or writeback caching (<code>cache.writeback=true</code>). That said this risk is really not different from the risk of two applications writing to the same file under normal conditions.</p> <p>Keep in mind that if out-of-band changes are made while also leveraging any caching of the filesystem layout such as with <code>cache.entry</code>, <code>cache.negative_entry</code>, <code>cache.attr</code>, <code>cache.symlinks</code>, or <code>cache.readdir</code> you may experience temporary inconsistency till the cache expires. mergerfs is not actively watching all branches for changes and the kernel will have no way to know anything changed so as to clear or ignore the cache. This is the same issue you can have with remote filesystems.</p>"},{"location":"faq/why_isnt_it_working/","title":"\"Why isn't it working?\"","text":""},{"location":"faq/why_isnt_it_working/#i-modified-mergerfs-config-but-it-still-behaves-the-same","title":"I modified mergerfs' config but it still behaves the same.","text":"<p>mergerfs, like other filesystems, are given their options/arguments at mount time. You can not simply modify the source of the configuration and have those settings applied any more than you would for other filesystems. It is the user's responsibility to restart mergerfs to pick up the changes or use the runtime interface.</p> <p>NOTE: the runtime interface is just for runtime changes. It does NOT save those changed values anywhere.</p>"},{"location":"faq/why_isnt_it_working/#why-are-all-my-files-ending-up-on-1-filesystem","title":"Why are all my files ending up on 1 filesystem?!","text":"<p>Did you start with empty filesystems? Are you using an <code>existing path</code> policy such as <code>epmfs</code>?</p> <p>If starting with a set of empty filesystems such a policy will select only 1 filesystem when the first directory is created. Anything created in that directory will be placed on the same branch because that is the point of such a policy. That is the expected behavior.</p> <p>This may catch users off guard but the point of those <code>existing path</code> policies is to preserve the directory layout and you need to consider what that means one event at a time.</p> <p>To \"fix\" this situation change the policy. Most users have little reason to use such a policy. See the quick start guide and FAQ for policy recommendations.</p>"},{"location":"faq/why_isnt_it_working/#why-do-i-get-an-out-of-space-no-space-left-on-device-enospc-error-even-though-there-appears-to-be-lots-of-space-available","title":"Why do I get an \"out of space\" / \"no space left on device\" / ENOSPC error even though there appears to be lots of space available?","text":"<p>First make sure you've read the sections about policies, path preservation, branch filtering, and the options minfreespace, moveonenospc, statfs, and statfs_ignore.</p> <p>mergerfs is simply presenting a union of the content within multiple branches. The reported free space is an aggregate of space available within the pool (behavior modified by <code>statfs</code> and <code>statfs_ignore</code>). It does not represent a contiguous space. In the same way that read-only filesystems, those with quotas, or reserved space report the full theoretical space available. Not the practical usable space.</p> <p>Due to using an <code>existing path</code> based policy, setting a branch's mode to <code>NC</code> or <code>RO</code>, a filesystems read-only status, and/or <code>minfreespace</code> setting it is perfectly valid that <code>ENOSPC</code> / \"out of space\" / \"no space left on device\" be returned when attempting to create a file despite there being actual space available somewhere in the pool. It is doing what was asked of it: filtering possible branches due to those settings. If that is not the behavior you want you need to modify the settings accordingly.</p> <p>It is also possible that the filesystem selected has run out of inodes. Use <code>df -i</code> to list the total and available inodes per filesystem.</p>"},{"location":"faq/why_isnt_it_working/#why-isnt-the-create-policy-working","title":"Why isn't the create policy working?","text":"<p>It probably is. The policies rather straight forward and well tested.</p> <p>First, confirm the policy is configured as expected by using the runtime interface.</p> <pre><code>$ getfattr -n user.mergerfs.category.create /mnt/mergerfs/.mergerfs\n# file: mnt/mergerfs/.mergerfs\nuser.mergerfs.category.create=\"mfs\"\n</code></pre> <p>Second, as discussed in the support section, test the behavior using simple command line tools such as <code>touch</code> and then see where it was created.</p> <pre><code>$ touch /mnt/mergerfs/new-file\n$ getfattr -n user.mergerfs.allpaths /mnt/mergerfs/new-file\n# file: mnt/mergerfs/new-file\nuser.mergerfs.allpaths=\"/mnt/hdd/drive1/new-file\"\n</code></pre> <p>If the location of the file is where it should be according to the state of the system at the time and the policy selected then the \"problem\" lies elsewhere.</p> <p>Keep in mind that files, when created, have no size. If a number of files are created at the same time, for example by a program downloading numerous files like a BitTorrent client, then depending on the policy the files could be created on the same branch. As the files are written to, or resized immediately afterwards to the total size of the file being downloaded, the files will take up more space but there is no mechanism to move them as they grow. Nor would it be a good idea to do so as it would be expensive to continuously calculate their size and perform the move while the file is still being written to. As such an imbalance will occur that wouldn't if the files had been created and resized one at a time.</p> <p>If you wish to reduce the likelihood of this happening a policy that does not make decisions on available space alone such as <code>pfrd</code> or <code>rand</code> should be used.</p>"},{"location":"faq/why_isnt_it_working/#why-cant-i-see-my-files-directories","title":"Why can't I see my files / directories?","text":"<p>It's almost always a permissions issue. Unlike mhddfs and unionfs-fuse, which accesses content as root, mergerfs always changes its credentials to that of the caller. This is done as it is the only properly secure way to manage permissions. This means that if the user does not have access to a file or directory than neither will mergerfs. However, because mergerfs is creating a union of paths it may be able to read some files and directories on one filesystem but not another resulting in an incomplete set. And if one of the branches it can access is empty then it will return an empty list.</p> <p>Try using mergerfs.fsck tool to check for and fix inconsistencies in permissions. If you aren't seeing anything at all be sure that the basic permissions are correct. The user and group values are correct and that directories have their executable bit set. A common mistake by users new to Linux is to <code>chmod -R 644</code> when they should have <code>chmod -R u=rwX,go=rX</code>.</p> <p>If using a network filesystem such as NFS or SMB (Samba) be sure to pay close attention to anything regarding permissioning and users. Root squashing and user translation for instance has bitten a few mergerfs users. Some of these also affect the use of mergerfs from container platforms such as Docker.</p>"},{"location":"faq/why_isnt_it_working/#why-are-file-moves-renames-linkshardlinks-failing","title":"Why are file moves, renames, links/hardlinks failing?","text":"<p>mergerfs fully supports rename and link functions to the degree that is possible in a union filesystem. Problems related to rename and link are almost exclusively due to incorrect setup of software or poorly written software.</p>"},{"location":"faq/why_isnt_it_working/#docker-podman-and-other-container-runtimes","title":"Docker, Podman, and other container runtimes","text":"<p>Keep in mind that rename and link will NOT work across devices. That includes between the original filesystem and a mergerfs pool, between two separate pools of the same underlying filesystems, or bind mounts of paths within the mergerfs pool. The latter is common when using Docker, Podman, or other container runtimes. Multiple volumes (bind mounts) to the same underlying filesystem are considered different devices. There is no way to link or rename between them despite them binding to the same underlying filesystem. Neither mergerfs or any other filesystem has a say in this behavior as the kernel is erroring out before the request even gets to the filesystems in question.</p> <p>To work around this situation the highest directory in the mergerfs pool that includes all the paths you need is what should be bind'ed into the container if you want links and rename to work between the paths in question.</p> <p>This is a common problem for users of Radarr, Sonarr, Lidarr, etc. when they use the default volume mount options suggested by projects like LinuxServer.io. Do not use separate \"movies\" and \"downloads\" volumes.</p> <pre><code># NO\nvolumes:\n  - /mnt/pool/movies:/movies\n  - /mnt/pool/downloads:/downloads\n\n# YES\nvolumes:\n  - /mnt/pool:/media\n# Then use /media/movies and /media/downloads in your software.\n</code></pre>"},{"location":"faq/why_isnt_it_working/#path-preserving-create-policies","title":"Path-Preserving Create Policies","text":"<p>As described in the rename and link docs if a path-preserving create policy is configured then mergerfs, in order to follow that restrictive policy, must return an error (EXDEV) if the target path of a rename or link is not found on the target branch.</p> <pre><code>EXDEV  oldpath and newpath are not on the same mounted filesystem.\n       (Linux permits a filesystem to be mounted at multiple\n       points, but rename() does not work across different mount\n       points, even if the same filesystem is mounted on both.)\n</code></pre> <p>Most users do not have a need for path-preserving policies but if you intend on using path-preserving policies you must accept that <code>EXDEV</code> errors are more likely to occur. You could enable ignorepponrename however doing so would contradict the intention of using a path restrictive policy.</p>"},{"location":"faq/why_isnt_it_working/#poorly-written-software","title":"Poorly written software","text":"<p>There are some pieces of software that do not properly handle <code>EXDEV</code> errors which <code>rename</code> and <code>link</code> may return even though they are perfectly valid situations and do not indicate actual device, filesystem, or OS problems. The error will rarely be returned by mergerfs if using a non-path preserving policy however there are edge cases where it may (such as mounting another filesystem into the mergerfs pool.) If you do not care about path preservation set the mergerfs policy to the non-path preserving variant. For example: <code>-o category.create=pfrd</code>. Ideally the offending software would be fixed and it is recommended that if you run into this problem you contact the software's author and request proper handling of <code>EXDEV</code> errors.</p>"},{"location":"faq/why_isnt_it_working/#additional-reading","title":"Additional Reading","text":"<ul> <li>rename and link</li> <li>Do hardlinks work?</li> <li>How does mergerfs handle moving and copying of files?</li> <li>Moving files and directories fails with Samba</li> </ul>"},{"location":"faq/why_isnt_it_working/#why-is-rtorrent-failing-with-enodev-no-such-device","title":"Why is rtorrent failing with ENODEV (No such device)?","text":"<p>Be sure to set cache.files=partial|full|auto-full|per-process or use Linux kernel v6.6 or above. rtorrent and some other applications use mmap to read and write to files and offer no fallback to traditional methods.</p>"},{"location":"faq/why_isnt_it_working/#why-dont-i-see-mergerfs-options-in-mount-command-or-procmounts","title":"Why don't I see mergerfs options in mount command or /proc/mounts?","text":"<p>FUSE filesystems, such as mergerfs, are interpreting most of the possible options rather than being given to the kernel where those options in the <code>mount</code> command and /proc/mounts come from.</p> <p>If you want to see the options of a running instance of mergerfs you can use the runtime interface.</p>"},{"location":"setup/build/","title":"Build","text":"<p>NOTE: Prebuilt packages can be found at and recommended for most users: https://github.com/trapexit/mergerfs/releases</p> <p>NOTE: Only tagged releases are supported. <code>master</code> and other branches should be considered works in progress.</p> <p>First, get the code from github.</p> <pre><code>$ git clone https://github.com/trapexit/mergerfs.git\n$ # or\n$ wget https://github.com/trapexit/mergerfs/releases/download/&lt;ver&gt;/mergerfs-&lt;ver&gt;.tar.gz\n</code></pre>"},{"location":"setup/build/#debian-ubuntu","title":"Debian / Ubuntu","text":"<pre><code>$ cd mergerfs\n$ sudo buildtools/install-build-pkgs\n$ make deb\n$ sudo dpkg -i ../mergerfs_&lt;version&gt;_&lt;arch&gt;.deb\n</code></pre>"},{"location":"setup/build/#rhel-centos-rocky-fedora","title":"RHEL / CentOS / Rocky / Fedora","text":"<pre><code>$ su -\n# cd mergerfs\n# buildtools/install-build-pkgs\n# make rpm\n# rpm -i rpmbuild/RPMS/&lt;arch&gt;/mergerfs-&lt;version&gt;.&lt;arch&gt;.rpm\n</code></pre>"},{"location":"setup/build/#generic-linux","title":"Generic Linux","text":"<p>Have git, g++ or clang, make, python installed.</p> <pre><code>$ cd mergerfs\n$ make\n$ sudo make install\n</code></pre>"},{"location":"setup/build/#freebsd","title":"FreeBSD","text":"<p>Have git, g++ or clang, gmake, python installed.</p> <pre><code>$ cd mergerfs\n$ gmake\n$ gmake install # as root\n</code></pre>"},{"location":"setup/build/#build-options","title":"Build options","text":"<pre><code>$ make help\nusage: make\n\nmake USE_XATTR=0      - build program without xattrs functionality\nmake STATIC=1         - build static binary\nmake LTO=1            - build with link time optimization\n</code></pre>"},{"location":"setup/installation/","title":"Installation","text":"<p>If you are using a non-rolling release Linux distro such as Debian or Ubuntu then you are almost certainly going to have an old version of mergerfs installed if you use the \"official\" package. For that reason we provide packages for major stable released distros.</p> <p>Before reporting issues or bugs please be sure to upgrade to the latest release to confirm they still exist.</p> <p>All provided packages can be found at https://github.com/trapexit/mergerfs/releases</p>"},{"location":"setup/installation/#archlinux","title":"ArchLinux","text":"<ol> <li>Setup AUR</li> <li><code>pacman -S mergerfs</code></li> </ol>"},{"location":"setup/installation/#centos-rocky","title":"CentOS / Rocky","text":"<p>Get the RPM from the releases page.</p> <pre><code>wget https://github.com/trapexit/mergerfs/releases/download/&lt;ver&gt;/mergerfs-&lt;ver&gt;.el&lt;rel&gt;.&lt;arch&gt;.rpm\nsudo rpm -i mergerfs-&lt;ver&gt;.el&lt;rel&gt;.&lt;arch&gt;.rpm\n</code></pre>"},{"location":"setup/installation/#debian-based-os","title":"Debian based OS","text":"<p>Debian/Ubuntu/Raspberry Pi</p> <p>Most Debian based OS installs are of a stable branch and therefore do not have the most up to date software. While mergerfs is available via <code>apt</code> it is suggested that users install the most recent version available from the releases page.</p>"},{"location":"setup/installation/#prebuilt-deb","title":"prebuilt deb","text":""},{"location":"setup/installation/#debian","title":"Debian","text":"<pre><code>wget https://github.com/trapexit/mergerfs/releases/download/&lt;ver&gt;/mergerfs_&lt;ver&gt;.debian-&lt;rel&gt;_&lt;arch&gt;.deb\nsudo dpkg -i mergerfs_&lt;ver&gt;.debian-&lt;rel&gt;_&lt;arch&gt;.deb\n</code></pre>"},{"location":"setup/installation/#ubuntu","title":"Ubuntu","text":"<pre><code>wget https://github.com/trapexit/mergerfs/releases/download/&lt;version&gt;/mergerfs_&lt;ver&gt;.ubuntu-&lt;rel&gt;_&lt;arch&gt;.deb\nsudo dpkg -i mergerfs_&lt;ver&gt;.ubuntu-&lt;rel&gt;_&lt;arch&gt;.deb\n</code></pre>"},{"location":"setup/installation/#apt","title":"apt","text":"<pre><code>sudo apt install -y mergerfs\n</code></pre>"},{"location":"setup/installation/#fedora","title":"Fedora","text":"<p>Get the RPM from the releases page.</p> <pre><code>wget https://github.com/trapexit/mergerfs/releases/download/&lt;ver&gt;/mergerfs-&lt;ver&gt;.fc&lt;rel&gt;.&lt;arch&gt;.rpm\nsudo rpm -i mergerfs-&lt;ver&gt;.fc&lt;rel&gt;.&lt;arch&gt;.rpm\n</code></pre>"},{"location":"setup/installation/#suseopensuse","title":"SUSE/OpenSUSE","text":"<p>Avaliable at filesystems repo</p> <p>if you have not added the repo (e.g. in case of OpenSUSE Tumbleweed, rel=openSUSE_Tumbleweed): </p> <pre><code>zypper addrepo https://download.opensuse.org/repositories/filesystems/&lt;rel&gt;/filesystems.repo\nzypper refresh\nzypper install mergerfs\n</code></pre>"},{"location":"setup/installation/#freebsd","title":"FreeBSD","text":"<p>https://www.freshports.org/filesystems/mergerfs</p> <pre><code>pkg install filesystems/mergerfs\n</code></pre>"},{"location":"setup/installation/#nixos","title":"NixOS","text":"<p>search.nixos.org</p> <pre><code>nix-env -iA nixos.mergerfs\n</code></pre>"},{"location":"setup/installation/#other-linux-distros","title":"Other Linux Distros","text":"<p>Check your distro.</p>"},{"location":"setup/installation/#static-linux-binaries","title":"Static Linux Binaries","text":"<p>If your distro does not package mergerfs there are static binaries provided.</p> <p>Get the tarball from the releases page.</p> <pre><code>wget https://github.com/trapexit/mergerfs/releases/download/&lt;ver&gt;/mergerfs-static-linux_&lt;arch&gt;.tar.gz\nsudo tar xvf mergerfs-static-linux_&lt;arch&gt;.tar.gz -C /\n</code></pre>"},{"location":"setup/upgrade/","title":"Upgrade","text":"<p>mergerfs can be upgraded live by mounting on top of the previous instance. Simply install the new version of mergerfs and follow the instructions below.</p> <p>Run mergerfs again or if using <code>/etc/fstab</code> (or systemd mount file) call for it to mount again. Existing open files and directories will continue to work fine though they won't see any differences that the new version would provide since it is still using the previous instance. If you plan on changing settings with the new mount you should / could apply those before mounting the new version.</p> <pre><code>$ sudo mount /mnt/mergerfs\n$ mount | grep mergerfs\nmedia on /mnt/mergerfs type mergerfs (rw,relatime,user_id=0,group_id=0,default_permissions,allow_other)\nmedia on /mnt/mergerfs type mergerfs (rw,relatime,user_id=0,group_id=0,default_permissions,allow_other)\n</code></pre> <p>A problem with this approach is that the underlying instance will continue to run even if the software using it stop or are restarted. To work around this you can use a \"lazy umount\". Before mounting over top the mount point with the new instance of mergerfs issue: <code>umount -l &lt;mergerfs_mountpoint&gt;</code>. Or you can let mergerfs do it by setting the option <code>lazy-umount-mountpoint=true</code>.</p> <p>If the intent is to change settings at runtime then the runtime interface should be used.</p>"}]}